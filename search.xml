<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微机原理第三章数据传输指令]]></title>
    <url>%2F2019%2F10%2F14%2F%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于hexo博客换主题踩坑记录]]></title>
    <url>%2F2019%2F10%2F10%2F%E5%85%B3%E4%BA%8Ehexo%E5%8D%9A%E5%AE%A2%E6%8D%A2%E4%B8%BB%E9%A2%98%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[问题:hexo更换主题后github远程并不更新解决方法:删除博客根目录下的public目录和隐藏文件夹.deploy_git删除后再执行hexo g和hexo d]]></content>
      <categories>
        <category>blog</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法课4]]></title>
    <url>%2F2019%2F10%2F07%2F%E7%AE%97%E6%B3%95%E8%AF%BE4%2F</url>
    <content type="text"><![CDATA[0-1背包问题动态规划递推公式: 伪代码: 代码实现:12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;int Knapsack(int* S,int* V,int n,int s)&#123; int* prev = new int[s+1]; int* pres = new int[s+1]; int* tmp; fill(prev, prev+s+1, 0); pres[0] = 0; for (int i=1; i&lt;=n; i++) &#123; for (int j = 1; j&lt;=s; j++) &#123; if (j&lt;S[i]) &#123; pres[j] = prev[j]; &#125; else&#123; pres[j]=max(prev[j],prev[j-S[i]]+V[i]); &#125; &#125; tmp = prev; prev = pres; pres =tmp; pres[0]=0; &#125; delete [] prev; delete [] pres; return prev[s];&#125;int main(int argc, const char * argv[]) &#123; int S[5]&#123;0,2,3,4,5&#125;; int V[5]&#123;0,3,4,5,7&#125;; int s = 9; int result = Knapsack(S,V,sizeof(S)/sizeof(int)-1,s); cout&lt;&lt;result; return 0;&#125; FLOYD算法算法目标:计算图中每个节点对之间的最短距离 算法思想(个人理解):动态规划思想,每次加入一个节点进行考虑,问题规模增加一个节点,对该节点进行分类讨论: 不把这个节点加入到路径中 把这个节点加入到路径中,即该新增加节点必须在路径中 动态规划递推式:Dk[i, j]=min{Dk-1[i, j], Dk-1[i, k]+Dk-1[k, j]} 伪代码: 代码实现:1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;const int big =10000;using namespace std;vector&lt;vector&lt;int&gt;&gt; FLOYD(vector&lt;vector&lt;int&gt;&gt;distance)&#123; unsigned long n = distance[0].size(); for (int count = 1; count&lt;=n; count++) &#123; for (int i=0; i&lt;n; i++) &#123; for (int j=0; j&lt;n; j++) &#123; distance[i][j]=min(distance[i][j],distance[i][count-1]+distance[count-1][j]); &#125; &#125; &#125; return distance;&#125;int main(int argc, const char * argv[]) &#123; vector&lt;vector&lt;int&gt;&gt;distance&#123;&#123;0,2,9&#125;,&#123;8,0,6&#125;,&#123;1,big,0&#125;&#125;; vector&lt;vector&lt;int&gt;&gt; result=FLOYD(distance); for (auto x = result.begin(); x!=result.end(); x++) &#123; for (auto y = x-&gt;begin(); y!=x-&gt;end(); y++) &#123; cout&lt;&lt;*y&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 实例运行结果: 狄杰斯特拉算法算法目标:寻找指定起始节点到图中每个节点的最短路径 算法思想(个人理解):贪心思想,创建一个路径节点集合,每次都加入一条最短的边(该边两个端点必须一个端点在路径端点集合中一个不在集合中),每加入一条边就将边的不在集合中的端点加入到路径节点集合中,直到路径节点集合中节点个数等于图中节点个数. 代码实现:解释: work向量数组作用:储存起始节点到其他个个节点的最短距离,路径节点集合每加进去一个节点就,更新一波,原因是加进去的新节点可能可以减小起始节点到个个节点的距离 delete_array数组作用:路径节点集合,每个元素对应一个节点是否被加入到路径集合,true为加入,反之还未加入 prev数组记录对应节点的前趋节点,以便最后打印最短路径 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;const int big = 10000;using namespace std;int __Minimum__(bool* delete_array,vector&lt;int&gt;&amp; work)&#123; int result; for (int i=0; i&lt;work.size(); i++) &#123; if (!delete_array[i]) &#123; result = i; break; &#125; &#125; for (int i=1; i&lt;work.size(); i++) &#123; if (work[result]&gt;work[i] &amp;&amp; !delete_array[i]) &#123; result = i; &#125; &#125; return result;&#125;void Dijkstra(const vector&lt;vector&lt;int&gt;&gt;&amp; D)&#123; unsigned long x = D.size(); int prev[x]; prev[0] = -1; for (int i=1;i&lt;x;i++) &#123; if (D[0][i]!=big) &#123; prev[i]=0; &#125; &#125; vector&lt;int&gt; work(D[0].begin(),D[0].end()); bool delete_array[x]; fill(delete_array, delete_array+x, false); delete_array[0]=true; for (int i=1; i&lt;x; i++) &#123; int min_id = __Minimum__(delete_array, work); delete_array[min_id] = true; for (int j=0; j&lt;x; j++) &#123; if (D[min_id][j]+work[min_id]&lt;work[j] &amp;&amp; !delete_array[j]) &#123; work[j] = D[min_id][j]+work[min_id]; prev[j]=min_id; &#125; &#125; &#125; for (auto iter=work.begin(); iter!=work.end(); iter++) &#123; cout&lt;&lt;*iter&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; for (int i=1; i&lt;x; i++) &#123; int j=i; stack&lt;int&gt; Stack; while (prev[j]!=-1) &#123; Stack.push(prev[j]); j=prev[j]; &#125; cout&lt;&lt;&quot;结点0到结点&quot;&lt;&lt;i&lt;&lt;&quot;: &quot;; while (!Stack.empty()) &#123; cout&lt;&lt;Stack.top()&lt;&lt;&quot;-&gt;&quot;; Stack.pop(); &#125; cout&lt;&lt;i&lt;&lt;endl; &#125;&#125;int main(int argc, const char * argv[]) &#123; vector&lt;vector&lt;int&gt;&gt; a&#123; &#123;0,1,12,big,big,big&#125;, &#123;big,0,9,3,big,big&#125;, &#123;big,big,0,big,5,big&#125;, &#123;big,big,4,0,13,15&#125;, &#123;big,big,big,big,0,4&#125;, &#123;big,big,big,big,big,0&#125; &#125;; Dijkstra(a); return 0;&#125; 实例:代码结果: 克鲁斯卡尔算法算法目标:产生最小生成树(包含图中所有节点,且所有路径权重之和最小的树) 算法思想(个人理解):贪心算法,将图拆成n个节点,每次产生一条最短的边,这条边将两棵树连接起来,这就要求这条最短的边的两个端点分别在不同的树上,否则将产生回环 代码实现:解释: tree数组用来标记两个节点所在的树🌲,数组中每个元素的值表示对应节点所在的树的编号,初始化时每个节点就是一棵树,当产生一条最短的边,这条边将两棵树连接起来时,两棵树合并,我的默认合并方式是编号大的树的所有节点编号都改为编号小的树的编号 edge数组用来储存所有的边 代码思路:将图的所有边排序,选择符合要求(权值小,两端点不在同一棵树上)的最小的n-1条边 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;#define SIZE 7using namespace std;struct Edge&#123; int x; int y; int weight; bool flag; Edge&amp; operator=(const Edge a)&#123; x=a.x; y=a.y; weight=a.weight; flag=a.flag; return *this; &#125;&#125;;inline int mininum(int a,int b)&#123; return a&gt;b?b:a;&#125;inline int maxinum(int a,int b)&#123; return a&gt;b?a:b;&#125;void selection_sort(Edge* A,int size)&#123; int i=1,k; int the_smallest; while (i&lt;size) &#123; k=i-1; the_smallest=A[k].weight; for (int j=i; j&lt;size; j++) &#123; if (the_smallest&gt;A[j].weight)&#123; k=j; the_smallest=A[k].weight; &#125; &#125; if (k != i-1) &#123; Edge tmp=A[i-1]; A[i-1]=A[k]; A[k]=tmp; &#125; i++; &#125;&#125;void Kruskal(int distance_array[][SIZE],int N)&#123; int tree[N+1]; for (int i = 1; i&lt;=N; i++) &#123; tree[i]=i; &#125; int edge_number = (N-1)*N/2; Edge edge[edge_number]; int index = 0; for (int i = 1; i&lt;N; i++) &#123; for (int j=i+1; j&lt;=N; j++) &#123; edge[index].x = i; edge[index].y = j; edge[index].weight =distance_array[i][j]; edge[index].flag = false; index++; &#125; &#125; selection_sort(edge, edge_number); for (int i = 1; i&lt;N; i++) &#123; for (int j=0; j&lt;edge_number; j++) &#123; if (!edge[j].flag &amp;&amp; tree[edge[j].x]!=tree[edge[j].y]) &#123; edge[j].flag=true; int min = mininum(edge[j].x, edge[j].y); int max = maxinum(edge[j].x, edge[j].y); for (int k=1; k&lt;=N; k++) &#123; if (tree[k]==tree[max]) &#123; tree[k]=tree[min]; &#125; &#125; break; &#125; &#125; &#125; for (int i = 0; i&lt;edge_number; i++) &#123; if (edge[i].flag) &#123; cout&lt;&lt;edge[i].x&lt;&lt;&quot;-&gt;&quot;&lt;&lt;edge[i].y&lt;&lt;endl; &#125; &#125; &#125;int main(int argc, const char * argv[]) &#123; const int N =SIZE-1; const int inf = 10000; int distance[SIZE][SIZE]&#123; &#123;0,0,0,0,0,0,0&#125;, &#123;0,0,1,2,inf,inf,inf&#125;, &#123;0,1,0,6,11,inf,inf&#125;, &#123;0,2,6,0,9,13,inf&#125;, &#123;0,inf,11,9,0,7,3&#125;, &#123;0,inf,inf,13,7,0,4&#125;, &#123;0,inf,inf,inf,3,4,0&#125; &#125;; Kruskal(distance, N); return 0;&#125; 实例:代码结果: 哈夫曼编码算法目标:产生哈夫曼树,用以编码,按字符的出现频率来编码,出现频率越高的字符的编码越短. 算法思想(个人理解):贪心思想,每次合并两个最小的节点产生一个新节点作为该两节点的根结点,该新节点的频率值为两节点频率之和,之后新节点代替两节点进行以后的排序 代码实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;iostream&gt;using namespace std;inline int minimun(int a,int b)&#123; return a&gt;b?b:a;&#125;inline int maximun(int a,int b)&#123; return a&gt;b?a:b;&#125;struct node&#123; node* leftchild; node* rightchild; char val; int frequency;&#125;;struct min1_and_min2&#123; int index1; int index2;&#125;;struct mystack&#123; int* stack; int top; mystack(int capacity)&#123; stack = new int[capacity]; top = 0; &#125; ~mystack()&#123; delete [] stack; &#125; void push(int i)&#123; stack[top++]=i; &#125; void pop()&#123; top--; &#125; void print()&#123; for(int i=0;i&lt;top;i++)&#123; cout&lt;&lt;stack[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;&#125;;void Encode(node* root,mystack&amp; stack)&#123; if(root-&gt;leftchild == nullptr)&#123; cout&lt;&lt;root-&gt;val&lt;&lt;&quot;:&quot;&lt;&lt;endl; stack.print(); return; &#125; stack.push(0); Encode(root-&gt;leftchild,stack); stack.pop(); stack.push(1); Encode(root-&gt;rightchild,stack); stack.pop();&#125;void Decode(int* code,int size,node* root)&#123; node* now=root; for (int i=0; i&lt;size; i++) &#123; if (code[i]) &#123; now = now-&gt;rightchild; if (now-&gt;rightchild == nullptr) &#123; cout&lt;&lt;now-&gt;val; now = root; &#125; &#125;else&#123; now = now-&gt;leftchild; if (now-&gt;rightchild == nullptr) &#123; cout&lt;&lt;now-&gt;val; now = root; &#125; &#125; &#125; &#125;//N:array数组的大小min1_and_min2 find(node* array,bool* flag,int N)&#123; int index[2]; int index1,index2; int count = 0; for (int i=0; i&lt;N; i++) &#123; if (!flag[i]) &#123; index[count++] = i; if (count == 2) &#123; break; &#125; &#125; &#125; index1 =minimun(index[0], index[1]); index2 =maximun(index[0], index[1]); for (int i=0; i&lt;N; i++) &#123; if (!flag[i]) &#123; if (array[i].frequency&lt;array[index2].frequency &amp;&amp; array[i].frequency&gt;array[index1].frequency) &#123; index2 = i; &#125; if (array[i].frequency&lt;array[index1].frequency) &#123; index2 = index1; index1 = i; &#125; &#125; &#125; return min1_and_min2&#123;index1,index2&#125;;&#125;node* Huffman(node* array,int N)&#123; cout&lt;&lt;boolalpha; int end=N; bool flag[2*N-1]; fill(flag, flag+2*N-1, false); for (int i=1; i&lt;N; i++) &#123; min1_and_min2 a=find(array,flag,end); array[end].frequency=array[a.index1].frequency+array[a.index2].frequency; array[end].leftchild = &amp;array[a.index1]; array[end].rightchild = &amp;array[a.index2]; end++; flag[a.index1]=true; flag[a.index2]=true; &#125; return &amp;array[end-1]; &#125;int main(int argc, const char * argv[]) &#123; const int size = 9; int frequency[size]&#123;20,7,10,4,18,3,2,5,40&#125;; char var[size]=&#123;&apos;a&apos;,&apos;b&apos;,&apos;e&apos;,&apos;o&apos;,&apos;r&apos;,&apos;s&apos;,&apos;u&apos;,&apos;y&apos;,&apos; &apos;&#125;; node huffmantree[2*size-1]; for (int i=0; i&lt;size; i++) &#123; huffmantree[i].leftchild = nullptr; huffmantree[i].rightchild = nullptr; huffmantree[i].frequency = frequency[i]; huffmantree[i].val = var[i]; &#125; node* root=Huffman(huffmantree, size); mystack stack(5); Encode(root,stack); int code[]=&#123;1,1,0,0,1,1,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,&#125;;//&quot;you are sb&quot;的编码 Decode(code, sizeof(code)/sizeof(int), root); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法课3]]></title>
    <url>%2F2019%2F09%2F17%2F%E7%AE%97%E6%B3%95%E8%AF%BE3%2F</url>
    <content type="text"><![CDATA[分治MINMAX寻找数组A中最大元素和最小元素 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;struct max_min&#123; int max; int min;&#125;;inline int max(int a,int b)&#123; return a&gt;b?a:b;&#125;inline int min(int a,int b)&#123; return a&gt;b?b:a;&#125;max_min __MINMAX__(int begin,int end,int* Array)&#123; if (end - begin == 1) &#123; return (Array[begin]&gt;Array[end])?max_min&#123;Array[begin],Array[end]&#125;:max_min&#123;Array[end],Array[begin]&#125;; &#125;else if (end == begin)&#123; return max_min&#123;Array[end],Array[begin]&#125;; &#125; else&#123; int mid = (begin+end)/2; auto tmp1 = __MINMAX__(begin, mid, Array); auto tmp2 = __MINMAX__(mid+1, end, Array); return max_min&#123;max(tmp1.max, tmp2.max),min(tmp1.min, tmp2.min)&#125;; &#125;&#125;max_min MINMAX(int* Array,int size)&#123; return __MINMAX__(0, size-1, Array);&#125;int main(int argc, const char * argv[]) &#123; int Array[]&#123;3,4,2,8,9,33,99,78,1,67,1111,98&#125;; max_min result=MINMAX(Array, sizeof(Array)/sizeof(int)); std::cout&lt;&lt;result.max&lt;&lt;&quot; &quot;&lt;&lt;result.min&lt;&lt;std::endl; return 0;&#125; 寻找中项和第K小元素算法输入:n个元素的数组A[1…n]和整数k,k属于[1,n]算法输出:A中的第k小元素算法实现细节:A数组用vector实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int __findmid5__(vector&lt;int&gt;&amp;&amp; vec)&#123; for (int count=0; count&lt;2; count++) &#123; int min_id=count; for (int i=count;i&lt;5;i++) &#123; if (vec[min_id]&gt;vec[i]) &#123; min_id=i; &#125; &#125; int tmp = vec[min_id]; vec[min_id] = vec[count]; vec[count] = tmp; &#125; return vec[2];&#125;;void __selection_sort__(vector&lt;int&gt;&amp; A)&#123; unsigned long size = A.size(); int i=1,k; int the_smallest; while (i&lt;size) &#123; k=i-1; the_smallest=A[k]; for (int j=i; j&lt;size; j++) &#123; if (the_smallest&gt;A[j])&#123; k=j; the_smallest=A[k]; &#125; &#125; if (k != i-1) &#123; int tmp=A[i-1]; A[i-1]=A[k]; A[k]=tmp; &#125; i++; &#125;&#125;int SELECT(vector&lt;int&gt;&amp; Array,unsigned long k)&#123; unsigned long size = Array.size(); if (size&lt;44) &#123; __selection_sort__(Array); return Array[k-1]; &#125;else&#123; unsigned long q =size/5; vector&lt;int&gt; M; auto begin = Array.begin(); for (int i=1; i&lt;=q; i++) &#123; M.push_back(__findmid5__(vector&lt;int&gt;(begin+(i-1)*5,begin+5*i))); &#125; int mm = SELECT(M,M.size()/2); vector&lt;int&gt; A1; vector&lt;int&gt; A2; vector&lt;int&gt; A3; for (auto iter=begin; iter!=Array.end(); iter++) &#123; if (*iter&lt;mm) &#123; A1.push_back(*iter); &#125;else if (*iter==mm)&#123; A2.push_back(*iter); &#125;else A3.push_back(*iter); &#125; unsigned long size_A1 = A1.size(); unsigned long size_A2 = A2.size(); if (size_A1 &gt;= k) SELECT(A1, k); else if (size_A1+size_A2 &gt;= k) return mm; else if (size_A1+size_A2 &lt; k) SELECT(A3, k-size_A1-size_A2); &#125; return -1;&#125;;int main(int argc, const char * argv[]) &#123; vector&lt;int&gt; Array&#123;8,33,17,51,57,49,35,11,25,37,14,3,2,13,52,12,6,29,32,54,5,16,22,23,7&#125;; //vector&lt;int&gt; Array&#123;8,33,17,51&#125;; int result = SELECT(Array,13); std::cout&lt;&lt;result; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法课2]]></title>
    <url>%2F2019%2F09%2F16%2F%E7%AE%97%E6%B3%95%E8%AF%BE2%2F</url>
    <content type="text"><![CDATA[SELECTIONSORTREC 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;void exchange(int i,int j, int* Array)&#123; int tmp=Array[j]; Array[j]=Array[i]; Array[i]=tmp;&#125;void sort(int begin,int end,int* Array)&#123; if (begin==end) &#123; return; &#125; else&#123; int min_id =begin; for (int i=begin+1; i&lt;=end; i++) &#123; if (Array[min_id]&gt;Array[i]) &#123; min_id=i; &#125; &#125; exchange(begin,min_id,Array); sort(begin+1, end, Array); &#125;&#125;int main(int argc, const char * argv[]) &#123; int A[]&#123;8,4,3,5,2,1,7,22,88,45,25&#125;; sort(0, sizeof(A)/sizeof(int)-1, A); for (auto i:A) &#123; std::cout&lt;&lt;i&lt;&lt;&quot; &quot;; &#125; return 0;&#125; 生成排列 1234567891011121314151617181920212223242526#include &lt;iostream&gt;void exchange(int i,int j, int* Array)&#123; int tmp=Array[j]; Array[j]=Array[i]; Array[i]=tmp;&#125;void perml(int begin,int end,int*Array)&#123; if (begin == end) &#123; for (int i=0 ;i&lt;=end;i++) &#123; std::cout&lt;&lt;Array[i]&lt;&lt;&quot; &quot;; &#125; std::cout&lt;&lt;std::endl; &#125; for (int i=begin; i&lt;=end; i++) &#123; exchange(i, begin, Array); perml(begin+1, end, Array); exchange(i, begin, Array); &#125;&#125;int main(int argc, const char * argv[]) &#123; int A[]&#123;1,2,3,4,5,6&#125;; perml(0, sizeof(A)/sizeof(int)-1, A); return 0;&#125; 寻找多数元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;bool __Majority(int* result,int* A,int first,int last)&#123; if (first &gt; last) &#123; return false; &#125; int x = A[first]; int count = 1; int i = 1; while (count &amp;&amp; (i+first)&lt;=last) &#123; if (x == A[first+i]) &#123; count++; i++; &#125;else&#123; count--; i++; &#125; &#125; if (!count) &#123; return __Majority(result, A, first+i, last); &#125; else&#123; *result = x; return true; &#125;&#125;;void Majority(int *A,int size)&#123; int result; if (__Majority(&amp;result, A, 0, size-1)) &#123; std::cout&lt;&lt;&quot;多数元素为:&quot;&lt;&lt;result&lt;&lt;std::endl; &#125;else std::cout&lt;&lt;&quot;没有多数元素&quot;&lt;&lt;std::endl;&#125;int main(int argc, const char * argv[]) &#123; int A[]&#123;2,3,4,4,4,5,6&#125;; int A1[]&#123;2,3,4,4,2,5&#125;; int A2[]&#123;2,3,2&#125;; int A3[]&#123;1&#125;; Majority(A, sizeof(A)/sizeof(int)); Majority(A1, sizeof(A1)/sizeof(int)); Majority(A2, sizeof(A2)/sizeof(int)); Majority(A3, sizeof(A3)/sizeof(int)); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C-并发与多线程第十一节笔记]]></title>
    <url>%2F2019%2F08%2F30%2FC-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E5%8D%81%E4%B8%80%E8%8A%82%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[std::future的成员函数 vaild()如果future对象可以调用get()就返回真,即future对象内有值 wait_for()返回值是线程状态future_status标记 future_status::timeout future_status::ready future_status::deffered 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;thread&gt;using namespace std;int A(int var)&#123; cout&lt;&lt;&quot;开始执行A() &quot;&lt;&lt;this_thread::get_id()&lt;&lt;endl; int a = var; chrono::milliseconds dura(5000); this_thread::sleep_for(dura); cout&lt;&lt;&quot;结束执行A()&quot;&lt;&lt;endl; return a;&#125;int main(int argc, const char * argv[]) &#123; future&lt;int&gt;result=async(launch::deferred, A, 250); future_status state=result.wait_for(chrono::microseconds(2000)); if (state==future_status::ready) &#123; cout&lt;&lt;&quot;线程执行完毕&quot;&lt;&lt;endl; &#125;else if (state==future_status::timeout)&#123; cout&lt;&lt;&quot;线程执行超时&quot;&lt;&lt;endl; &#125;else cout&lt;&lt;&quot;线程deffered&quot;&lt;&lt;endl; result.wait(); return 0;&#125; std::share_future类模版future对象的get()函数是移动语义,执行一次后future对象就为空了所以不能多次调用get()share_future对象的get()函数执行的是拷贝,可以多次调用 12345678int main(int argc, const char * argv[]) &#123; future&lt;int&gt;result=async(launch::deferred, A, 250); //shared_future&lt;int&gt;result_s(move(result));//注意移动语义 shared_future&lt;int&gt;result_s(result.share());//注意 cout&lt;&lt;result_s.get()&lt;&lt;endl; cout&lt;&lt;result_s.get()&lt;&lt;endl; return 0;&#125; 12345678int main(int argc, const char * argv[]) &#123; packaged_task&lt;int(int)&gt;pack_g(A); shared_future&lt;int&gt;result(pack_g.get_future());//注意:直接使用构造函数用临时future对象初始化shared_future对象 thread th_one(ref(pack_g),250); th_one.join(); cout&lt;&lt;result.get()&lt;&lt;endl; return 0;&#125; 原子操作std::atomicmutex互斥锁是对一段代码加锁原子操作是对一个变量操作reason: 12345678910111213int global_var=0;void B()&#123; for (int i=0; i&lt;1000000; i++) &#123; global_var++; &#125;&#125;int main(void)&#123; thread th_one(B); thread th_two(B); th_one.join(); th_two.join(); cout&lt;&lt;global_var;&#125; 运行结果: 12345678910111213std::atomic&lt;int&gt; global_var;void B()&#123; for (int i=0; i&lt;1000000; i++) &#123; global_var++; &#125;&#125;int main(void)&#123; thread th_one(B); thread th_two(B); th_one.join(); th_two.join(); cout&lt;&lt;global_var;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并发与多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法课1]]></title>
    <url>%2F2019%2F08%2F29%2F%E7%AE%97%E6%B3%95%E8%AF%BE1%2F</url>
    <content type="text"><![CDATA[二分查找 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt;Array&#123;2,4,5,7,8,9,18,28&#125;;int main(int argc, const char * argv[]) &#123; for (auto iter=Array.begin(); iter!=Array.end(); ++iter) &#123; unsigned long low = 0,high = Array.size()-1; unsigned long mid; unsigned long x,j=0; x=*iter; while (low&lt;=high) &#123; mid = (high + low)/2; if (Array[mid]==x) &#123; j=mid; break; &#125;else if (Array[mid]&lt;x)&#123; low=mid+1; &#125;else high=mid-1; &#125; cout&lt;&lt;x&lt;&lt;&quot; location:&quot;&lt;&lt;j&lt;&lt;endl; &#125; return 0;&#125; bottom-up merge sort 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int A[9]&#123;3,4,7,2,1,44,23,45,34&#125;;int B[10];void merge(int*A,int head_one,int head_two,int tail_two)&#123; int i=head_one,j=head_two; int p=head_one; while (i&lt;head_two &amp;&amp; j&lt;=tail_two) &#123; if (A[i]&lt;A[j]) &#123; B[p++]=A[i]; i++; &#125;else &#123; B[p++]=A[j]; j++; &#125; &#125; if (i==head_two) &#123; while (p&lt;=tail_two) &#123; B[p++]=A[j]; j++; &#125; &#125;else &#123; while (p&lt;=head_two) &#123; B[p++]=A[i]; i++; &#125; &#125; for (p=head_one; p&lt;=tail_two; p++) &#123; A[p]=B[p]; &#125;&#125;void bottom_up_sort(int* Array,int size)&#123; int t=1,s,i; while (t&lt;size) &#123; i=0;s=t;t=2*s; while (i+t&lt;size) &#123; merge(Array, i, i+s, i+t-1); i=i+t; &#125; if (i+s&lt;size) &#123; merge(Array, i, i+s, size-1); &#125; &#125;&#125; selection sort 1234567891011121314151617181920void selection_sort(int* A,int size)&#123; int i=1,k; int the_smallest; while (i&lt;size) &#123; k=i-1; the_smallest=A[k]; for (int j=i; j&lt;size; j++) &#123; if (the_smallest&gt;A[j])&#123; k=j; the_smallest=A[k]; &#125; &#125; if (k != i-1) &#123; int tmp=A[i-1]; A[i-1]=A[k]; A[k]=tmp; &#125; i++; &#125;&#125; insert sort 1234567891011121314151617181920212223void insert_sort(int *A,int size)&#123; int i=1,x; while (i&lt;size) &#123; x=A[i]; for (int j=i-1; j&gt;=0; j--) &#123; if (A[j]&gt;x) &#123; A[j+1]=A[j]; if (!j) &#123; A[0]=x; &#125; &#125; else&#123; A[j+1]=x; break; &#125; &#125; for (int i=0; i&lt;9; i++) &#123; std::cout&lt;&lt;A[i]&lt;&lt;&quot; &quot;; &#125; std::cout&lt;&lt;std::endl; i++; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++继承]]></title>
    <url>%2F2019%2F08%2F26%2FC-%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承语法:class 之类名:访问控制符 基类名1,基类名2 { }访问控制符省略的两种情况:1.若子类用class声明默认privite2.若子类用struct声明默认public 基类的公有成员 基类的受保护成员 基类的私有成员 子类公有继承 公 保 私 子类私有继承 私 私 私 子类保护继承 保 保 私 恢复从基类继承的成员的访问级别1.代码 12访问控制符:using 基类名::成员 2.访问级别不能比基类低or高,protect只能恢复为protect 只声明未定义的类不能作为基类 子类以任何方式继承,私有成员都不被继承,派生类只能通过基类的成员函数来访问基类私有成员 友元函数不被继承,如果希望派生类友元函数使用基类友元函数可以通过显示类型转换(或使用强制类型转换dynamic_cast&lt;&gt;)将派生类引用或指针转换为基类引用或指针 虚函数1.如果派生类重新定义基类方法则基类须将该方法定义为virtual2.注意如果基类中一函数被重载多次,在派生类中要重新定义该函数的话要将基类的该函数都在派生类中都定义一遍,见CPP第页在默认复制构造函数执行类成员复制时或继承类组件时,使用的是该类的复制构造函数 基类使用new,若派生类也使用new则派生类需要显示定义析构函数,显示复制构造函数,赋值运算符,若派生类不使用new,进行派生对象之间的赋值时,复制派生对象的基类部分时将自动调用基类赋值运算符注意:派生类的显示赋值运算符必须负责基类对象的赋值,可以在其赋值运算符内显式调用基类赋值运算符 protect受保护继承:1.对派生类来说相当于公有成员,对于外部而言,相当于私有成员不能直接访问,总的来说相当于派生类的受保护成员2.该成员不被外界访问]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++并发与多线程第十节笔记]]></title>
    <url>%2F2019%2F08%2F21%2FC-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E5%8D%81%E8%8A%82%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[知识点:std::async,future,package_task,promisestd::async、std::future创建后台任务并返回值 解析:希望线程返回一个结果std::async是一个函数模版,用来创建一个异步任务,启动异步任务后(创建一个线程并执行线程入口函数),返回值是一个std::future对象,std::future是类模版线程的返回结果通过future对象的get()成员函数取得std::future提供一种访问异步操作结果的机制,在线程执行完毕后可获得结果注意:future对象不可拷贝,只能移动move拷贝 代码:future result = async(A, var);马上创建线程并执行result.get():卡在该代码处等待线程执行完毕,并获取返回值,⚠️只能调用一次result.wait():等待线程返回,本身并不返回结果如果既不get()也不wait()主线程会在主线程return语句执行前等待子线程执行完毕后主线程才完毕12Test myobj;future&lt;int&gt; result = async(&amp;Test::A,ref(myobj),var); 线程入口函数为类的成员函数,第三个参数是成员函数的参数 std::async的参数一.std::launch::deffer:future&lt;int&gt; result = async(launch::deferred,A, var):表示线程入口函数延迟到调用get()或wait()函数才执行而且并不创建子线程只是在主线程中执行线程入口函数,如果不调用get(),线程根本不创建二.std::launch::async:future&lt;int&gt; result = async(launch::async,A, var):默认参数,创建子线程并开始运行 std::packaged_task希望打包任务,包装可调用对象是一个类模版,模版参数是各种可调用对象packaged_task&lt;int(int)&gt; mypt(A);其中int A(int a)packaged_task对象可直接调用相当于函数调用,如下:mypt(9)然后通过future对象获取返回值:future&lt;int&gt; result=mypt.get_future();cout&lt;&lt;result.get();代码实例: 123456789101112131415int main(int argc, const char * argv[]) &#123; list&lt;packaged_task&lt;int(int)&gt; &gt; task_list; packaged_task&lt;int(int)&gt; mypt(A); task_list.push_back(move(mypt)); packaged_task&lt;int(int)&gt; mypt2; auto iter = task_list.begin(); mypt2 = move(*iter); task_list.erase(iter); int a=9; thread th1(ref(mypt2),a); th1.join(); future&lt;int&gt; result=mypt2.get_future(); cout&lt;&lt;result.get(); return 0;&#125; std::promise类模版,在某个线程中赋值,在另一个线程中获取结果代码如下: 1234567891011121314151617181920212223void B(promise&lt;int&gt;&amp;promi,int var)&#123; cout&lt;&lt;&quot;开始执行A() &quot;&lt;&lt;this_thread::get_id()&lt;&lt;endl; int a = ++var; chrono::milliseconds dura(5000); this_thread::sleep_for(dura); promi.set_value(a);//注意 cout&lt;&lt;&quot;结束执行A()&quot;&lt;&lt;endl; return;&#125;void C(future&lt;int&gt;&amp; a)&#123; cout&lt;&lt;&quot;In thread C&quot;&lt;&lt;endl; cout&lt;&lt;a.get()&lt;&lt;endl;&#125;int main(int argc,const char *args[])&#123; cout&lt;&lt;this_thread::get_id()&lt;&lt;endl; promise&lt;int&gt; test; thread th1(B,ref(test),249); th1.join(); future&lt;int&gt; ful = test.get_future(); thread use_ful(C,ref(ful)); use_ful.join(); //cout&lt;&lt;ful.get();&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>并发与多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发与多进程之unique_lock]]></title>
    <url>%2F2019%2F08%2F15%2F%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8Bunique-lock%2F</url>
    <content type="text"><![CDATA[(1).unique_lock取代lock_guardlock_guardguard(lock1);改为unique_lockunique_lock1(lock1); (2).unique_lock的第二个参数 std::adopt_lock 12lock1.lock();unique_lock&lt;mutex&gt;unique_lock1(lock1,adopt_lock); std::try_to_lock 12345unique_lock&lt;mutex&gt;unique_lock1(lock1,try_to_lock);if (unique_lock1.owns_lock()) &#123; else cout&lt;&lt;&quot;outMsgRecQueue()在执行,但得不到锁&quot;&lt;&lt;endl; std::defer_lock 12unique_lock&lt;mutex&gt;unique_lock1(lock1,defer_lock);unique_lock1.lock(); (3).unique_lock模版类的成员函数 lock()配合defer参数 unlock() try_lock()尝试给互斥量加锁,如果拿不到锁返回false,反之true release()返回他所管理的mutex对象的指针,并释放所有权 (4).unique_lock所有权传递1. 12unique_lock&lt;mutex&gt;unique_lock1(lock1,defer_lock);unique_lock&lt;mutex&gt;unique_lock2(std::move(unique_lock1)); 2.移动构造函数 1234std::unique_lock&lt;mutex&gt;A()&#123;unique_lock&lt;mutex&gt;unique_lock1(lock1);return unique_lock;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>并发与多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互斥量and死锁]]></title>
    <url>%2F2019%2F08%2F14%2F%E4%BA%92%E6%96%A5%E9%87%8Fand%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[互斥量使用代码:123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;//头文件#include &lt;list&gt;using namespace std;class A&#123;private: mutex lock1;//互斥量 list&lt;int&gt; msgRecQueue;public: void inMsgRecQueue()&#123; for (int i=0; i&lt;10000 ; ++i) &#123; lock1.lock();//使用互斥量 cout&lt;&lt;&quot;inMsgRecQueue()执行,插入一个元素 &quot;&lt;&lt;i&lt;&lt;endl; msgRecQueue.push_back(i); lock1.unlock(); &#125; &#125; void outMsgRecQueue()&#123; int command; for (int i=0; i&lt;10000 ; ++i) &#123; if(!msgRecQueue.empty())&#123; lock1.lock(); command=msgRecQueue.front(); msgRecQueue.pop_front(); lock1.unlock(); cout&lt;&lt;&quot;outMsgRecQueue()执行,取出一个元素 &quot;&lt;&lt;command&lt;&lt;endl; &#125;else cout&lt;&lt;&quot;outMsgRecQueue()在执行,但队列中没有元素&quot;&lt;&lt;endl; &#125; cout&lt;&lt;&quot;end&quot;&lt;&lt;endl; &#125;&#125;;int main(int argc, const char * argv[]) &#123; A myobj; thread input_msg_T(&amp;A::inMsgRecQueue,ref(myobj)); thread ouput_msg_T(&amp;A::outMsgRecQueue,ref(myobj)); input_msg_T.join(); ouput_msg_T.join(); return 0;&#125; 使用互斥量注意事项1.lock()和unlock()成对使用,尤其在if else语句,几个出口几个unlock() 使用std::lock_guard类模版,自动unlock123456789void inMsgRecQueue()&#123; for (int i=0; i&lt;10000 ; ++i) &#123; lock_guard&lt;mutex&gt;guard(lock1); //lock1.lock(); cout&lt;&lt;&quot;inMsgRecQueue()执行,插入一个元素 &quot;&lt;&lt;i&lt;&lt;endl; msgRecQueue.push_back(i); //lock1.unlock(); &#125; &#125; 原理:析构函数析构对象解锁 死锁一个互斥量产生的死锁问题在同一个线程中获取互斥量多次,并且获取后不释放就直接再次获取 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;mutex&gt;struct Complex&#123; std::mutex lock; int i; Complex():i(4)&#123;&#125; void mul(int x)&#123; std::lock_guard&lt;std::mutex&gt; lg(lock); i *=x; &#125; void div(int x)&#123; std::lock_guard&lt;std::mutex&gt; lg(lock); i /=x; &#125; void both(int x,int y)&#123; std::lock_guard&lt;std::mutex&gt; lg(lock); div(x); mul(y); &#125;&#125;;int main(int argc, const char * argv[]) &#123; Complex complex; complex.both(4, 4); return 0;&#125; 解决方法:使用递归互斥量std::recursive_mutex允许同一线程多次获得该互斥量将代码中mutex lock改为recursive_mutex lock 俩个互斥量产生死锁问题两把锁(金锁,银锁)两个线程A,B线程A执行时,先锁金锁再锁银锁线程B执行时,先锁银锁再锁金锁上下文切换演示代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;list&gt;using namespace std;class A&#123;private: mutex lock1; mutex lock2; list&lt;int&gt; msgRecQueue;public: void inMsgRecQueue()&#123; for (int i=0; i&lt;10000 ; ++i) &#123; //lock_guard&lt;mutex&gt;guard(lock1); lock1.lock(); lock2.lock(); cout&lt;&lt;&quot;inMsgRecQueue()执行,插入一个元素 &quot;&lt;&lt;i&lt;&lt;endl; msgRecQueue.push_back(i); lock2.unlock(); lock1.unlock(); &#125; &#125; void outMsgRecQueue()&#123; int command; for (int i=0; i&lt;10000 ; ++i) &#123; if(!msgRecQueue.empty())&#123; lock2.lock(); lock1.lock(); command=msgRecQueue.front(); msgRecQueue.pop_front(); lock1.unlock(); lock2.unlock(); cout&lt;&lt;&quot;outMsgRecQueue()执行,取出一个元素 &quot;&lt;&lt;command&lt;&lt;endl; &#125;else cout&lt;&lt;&quot;outMsgRecQueue()在执行,但队列中没有元素&quot;&lt;&lt;endl; &#125; cout&lt;&lt;&quot;end&quot;&lt;&lt;endl; &#125;&#125;;int main(int argc, const char * argv[]) &#123; A myobj; thread input_msg_T(&amp;A::inMsgRecQueue,ref(myobj)); thread ouput_msg_T(&amp;A::outMsgRecQueue,ref(myobj)); input_msg_T.join(); ouput_msg_T.join(); return 0;&#125; 解决方法:互斥量lock顺序一样 std::lock()函数模版能力:一次锁住两个或以上互斥量,不存在死锁问题:要么两个互斥量都锁住要么都不锁 123456789101112void inMsgRecQueue()&#123; for (int i=0; i&lt;10000 ; ++i) &#123; //lock_guard&lt;mutex&gt;guard(lock1); //lock1.lock(); //lock2.lock(); std::lock(lock1, lock2); cout&lt;&lt;&quot;inMsgRecQueue()执行,插入一个元素 &quot;&lt;&lt;i&lt;&lt;endl; msgRecQueue.push_back(i); lock2.unlock();//还是要使用unlock(),fuck lock1.unlock(); &#125; &#125; 改进版本 1234567891011121314void inMsgRecQueue()&#123; for (int i=0; i&lt;10000 ; ++i) &#123; //lock_guard&lt;mutex&gt;guard(lock1); //lock1.lock(); //lock2.lock(); std::lock(lock1, lock2); lock_guard&lt;mutex&gt;guard1(lock1,adopt_lock); lock_guard&lt;mutex&gt;guard2(lock2,adopt_lock); cout&lt;&lt;&quot;inMsgRecQueue()执行,插入一个元素 &quot;&lt;&lt;i&lt;&lt;endl; msgRecQueue.push_back(i); //lock2.unlock(); // lock1.unlock();//不使用unlock() &#125; &#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>并发与多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态内存]]></title>
    <url>%2F2019%2F08%2F14%2F%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[1.格式: 12char *a=new char [20];delete [] a; 1.在构造函数中使用了new,在析构函数中应该使用delete2.new对应delete,new 类型[]对应delete[]指针3.多个构造函数中使用相同形式的new,不能有点使用new有的使用new[]4.delete可用在空指针5.在类中使用要显式定义复制构造函数和赋值运算符]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++类和对象1]]></title>
    <url>%2F2019%2F08%2F13%2FC-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A11%2F</url>
    <content type="text"><![CDATA[零碎知识点1.使用enum在类的public部分创建常量enum Mode{ ONE,TWE}2.定义类内特定的常量private:enum{A=250}static const int A=250;3.静态类成员static int a类的所有对象共享一个数据成员初始化:int class_name::a=20,位置在类声明之外,不带static关键字初始化在方法文件中,不能在头文件中,否则将出现多个初始化副本注意⚠️:如果静态成员是整形或枚举型const,可以在类声明中初始化4.C++自动提供下列成员函数5.使用const在类成员函数后加const可以防止函数修改调用它的对象 构造函数* 默认构造函数原型:class_name();如果定义了构造函数,将不会定义默认构造函数,如果要在创建对象是不显式初始化必须显式定义默认构造函数class_name::class_name(){}⚠️:没有参数或参数有默认值, 二者选其一用途:class_name obj时调用注意:构造函数不被继承;子类没有使用成员初始化列表调用基类构造函数将隐式调用基类默认构造函数,使用must确保默认构造函数存在 * 转换函数(将参数类型的值转换为类对象或将类转换为某种类型)1. 参数类型转换为类对象原型:class_name(double);只接受一个参数或第二个参数被提供了默认值使用explicit关键字可以关闭隐式转换explicit class_name (double var){},使用之后只允许使用显式强制类型转换 123class_name (double var)&#123;&#125;//转换函数class_name obj;obj=12.4; 分析:12.4调用转换函数生成临时对象,然后使用赋值运算符重载函数进行逐成员复制,此过程为隐式转换(自动进行)隐式类型转换发生场景一.class_name obj(12)二.obj=12三.将参数类型的值传递给接受以类为参数的函数四.返回值被声明为类时返回的却是参数类型 2. 类转换为参数类型原型:operator double() const注意:一.必须是类方法二.不能指定返回类型,double就是返回类型三.不能有参数四.使用explicit关键词可以避免隐式类型转换 * 复制构造函数原型:class_name(const class_name&amp; )使用一个对象来初始化另一个对象何时被调用:在按值传递对象和返回对象时被调用例子: 12345class_name A;class_name B(A);//1class_name B=A;//2等价于class_name B=class_name(A),调用的函数为class_name(const class_name &amp;)class_name B=class_name(A);//3class_name* B=new class_name(A);//4 ⚠️:第二三种方法:可能使用复制构造函数直接生成B对象,也可能使用复制构造函数生成临时对象在建临时对象复制给B第四种方法:初始化一个匿名对象然后将其地址赋给B指针默认复制构造函数:执行浅拷贝,复制的是成员的值需要显式定义复制构造函数的情况:1.类中包含了使用new初始化的指针成员 * 赋值运算符1.默认赋值运算符原型:class_name &amp; class_name::operator=(const class_name&amp;)2.何时被调用:将已有对象赋给另一对象,注意⚠️初始化时不一定会调用赋值运算符,参考复制构造函数的第二三种方法3.它是怎么赋值的:逐成员按值复制4.何时显式定义赋值运算符:看情况😓 析构函数基类一定要定义一个虚析构函数 静态成员函数:1.函数声明包含关键字static,函数定义不包含关键字2.不能通过对象调用3.不能使用this指针4.只能使用静态数据成员 返回对象的方式* 返回指向对象的引用一.类没有复制构造函数时必须返回对象的引用二.不使用复制构造函数三.在类继承使用虚函数时,指向基类的引用可以指向派生类两种常见的形式一.重载赋值运算符用途:s1=s2=s3二.重载与cout连用的&lt;&lt;运算符原因:ostream类没有复制构造函数 * 返回指向对象的const引用一.不能作为左值(如果参数是const&amp;a,要返回a,则返回类型必须声明为const&amp;,否则将const变量传给a形式参数可能存在利用返回值修改const变量的危险)二.省去拷贝构造 * 返回对象一.将调用复制构造函数构造一个调用程序可以访问的对象 * 返回const对象防止返回的临时对象被作为左值,将临时对象作为左值没有意义]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++友元]]></title>
    <url>%2F2019%2F08%2F13%2FC-%E5%8F%8B%E5%85%83%2F</url>
    <content type="text"><![CDATA[1. 三种友元1.友元函数2.友元类3.友元成员函数 2. 友元函数1.需要友元的场景:类重载二元运算符(+,*)2.注意点: 不能使用成员运算符(.)来调用 访问类的权限和成员函数相同,可以访问类私有数据 2.创建友元函数 原型放在类声明中在,在原型声明前加上friend关键字🌰:friend void function_name(var); 编写定义时不要使用类限定符(::),定义时也不要使用friend 在定义类尽情访问类私有数据 3.常用的友元函数(重载&lt;&lt;运算符) 1234ostream&amp; operator&lt;&lt;(ostream&amp; os,const class_name &amp; obj)&#123; os&lt;&lt;...; return os;&#125; 一些细节:返回值是引用;ostream类的引用可以引用ofstream对象,向下继承]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++重载]]></title>
    <url>%2F2019%2F08%2F13%2FC-%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[重载后的运算符必须有一个操作数是自定义的 不能重载下列运算符: 只能通过成员函数重载的运算符: 1.=:赋值运算符2.():函数调用运算符3.[]:中括号运算符4.-&gt;: 重载运算符 作为非成员函数(包括友元函数)最好是友元函数可以访问类的私有数据,两个操作数都作为参数传递 作为成员函数一个操作数通过this指针隐式传递,另一个作为函数参数传递 ⚠️二者选其一 中括号运算符重载原型:char &amp; operator[](int a):读写非const对象const char &amp; operator[](int a) const:读写const对象]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++并发与多线程2]]></title>
    <url>%2F2019%2F08%2F13%2FC-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B2%2F</url>
    <content type="text"><![CDATA[使用detach()注意点:1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;void myprint(const int &amp;i,char * paybuf)&#123; cout&lt;&lt;i&lt;&lt;endl; cout&lt;&lt;paybuf&lt;&lt;endl;&#125;int main(int argc, const char * argv[]) &#123; int mvar = 1; int &amp;mvary =mvar; char mybuf[] = &quot;this is a test&quot;; thread mytobj(myprint,mvar,mybuf); mytobj.detach(); cout&lt;&lt;&quot;I love china&quot;&lt;&lt;endl; return 0;&#125; 12345678910111213141516using namespace std;void myprint(const int &amp;i,const string &amp; paybuf)&#123;//试图使用隐式类型转换来构建一个string对象,而不用主线程中的变量 cout&lt;&lt;i&lt;&lt;endl; cout&lt;&lt;paybuf&lt;&lt;endl;&#125;int main(int argc, const char * argv[]) &#123; int mvar = 1; int &amp;mvary =mvar; char mybuf[] = &quot;this is a test&quot;; thread mytobj(myprint,mvar,mybuf); mytobj.detach(); cout&lt;&lt;&quot;I love china&quot;&lt;&lt;endl; return 0;&#125; 原因:主线程结束完毕后才构建临时对象string,而此时主线程中的变量已经失效被回收解决方法:将thread mytobj(myprint,mvar,mybuf);改为thread mytobj(myprint,mvar,string(mybuf));在创建线程的同时创建临时对象的方法传递参数是可行的验证如下: 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;class A&#123;public: int m_j; //类型转换构造函数 A(int a):m_j(a)&#123;cout&lt;&lt;&quot;构造函数执行&quot;&lt;&lt;this&lt;&lt;&quot; &quot;&lt;&lt;&quot; thread_id=&quot;&lt;&lt;std::this_thread::get_id()&lt;&lt;endl;&#125;; A(const A&amp;a):m_j(a.m_j)&#123;cout&lt;&lt;&quot;拷贝构造函数执行&quot;&lt;&lt;this &lt;&lt;&quot; &quot;&lt;&lt;&quot; thread_id=&quot;&lt;&lt;std::this_thread::get_id()&lt;&lt;endl;&#125;; ~A()&#123;cout&lt;&lt;&quot;析构函数执行&quot;&lt;&lt;this&lt;&lt;&quot; &quot;&lt;&lt;&quot; thread_id=&quot;&lt;&lt;std::this_thread::get_id()&lt;&lt;endl;&#125;;&#125;;void myprint(const int &amp;i,const string&amp; paybuf)&#123; //cout&lt;&lt;i&lt;&lt;endl; cout&lt;&lt; paybuf&lt;&lt;endl;&#125;void myprint1(const int &amp;i,const A&amp; paybuf)&#123; //cout&lt;&lt;i&lt;&lt;endl; cout&lt;&lt; &amp;paybuf&lt;&lt;endl;&#125;void myprint2(const A&amp; paybuf)&#123; cout&lt;&lt; &quot;子线程myprint2参数地址是&quot;&lt;&lt;&amp;paybuf&lt;&lt;&quot; thread_id=&quot;&lt;&lt;std::this_thread::get_id()&lt;&lt;endl;&#125;int main(int argc, const char * argv[]) &#123; int mvar = 1; //int mysecond=12; cout&lt;&lt;&quot;主线程ID是&quot;&lt;&lt;this_thread::get_id()&lt;&lt;endl; //char mybuf[] = &quot;this is a test&quot;; //thread mytobj(myprint1,mvar,A(mysecond));//希望整形传递给A类型对象 //thread mytobj(myprint,mvar,mybuf); thread mytobj(myprint2,mvar); mytobj.detach(); //mytobj.join(); //cout&lt;&lt;&quot;I love china&quot;&lt;&lt;endl; return 0;&#125; 结果:在子线程中构造对象,而此时主线程(detach)可能已经结束,构造函数的参数失效使用显示构造后,主线程会构造出子线程所需的拷贝对象以供拷贝,并在main函数结束前结束拷贝构造函数使子线程得到一个独立的对象修改后结果:使用detach总结:1.若传递int这种简单类型参数,建议都是值传递,不要用引用,更不能使用指针2.如果传递类对象,避免隐式类型转换,全部都在创建线程这一行就构建临时对象然后再函数参数里用引用来接3,建议不使用detach 临时对象作为线程参数线程ID:获取方法:std::this_thread::get_id()临时对象构造时机抓捕]]></content>
      <tags>
        <tag>C++</tag>
        <tag>并发与多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++并发与多线程1]]></title>
    <url>%2F2019%2F08%2F12%2FC-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B1%2F</url>
    <content type="text"><![CDATA[并发:两个或多个任务同时发生(进行) 主线程等待子线程执行完毕后自己才能退出1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//// main.cpp// 线程//// Created by zhouqionglin on 2019/8/12.// Copyright © 2019 周穹霖. All rights reserved.//#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;void myprint(void)&#123; cout&lt;&lt;&quot;我的线程myprint()开始执行了&quot;&lt;&lt;endl; cout&lt;&lt;&quot;我的线程myprint()结束了&quot;&lt;&lt;endl;&#125;class TA&#123;public: int a; TA(int a_a):a(a_a)&#123; cout&lt;&lt;&quot;拷贝构造函数被执行&quot;&lt;&lt;endl; &#125;; TA(const TA&amp; b):a(b.a)&#123;&#125;; ~TA()&#123; cout&lt;&lt;&quot;析构函数执行&quot;&lt;&lt;endl; &#125; void operator()()&#123; cout&lt;&lt;&quot;我的线程operator()开始执行了&quot;&lt;&lt;endl; cout&lt;&lt;&quot;我的线程operator()结束了&quot;&lt;&lt;endl; &#125;&#125;;int main(int argc, const char * argv[]) &#123; //1.用可调用对象创建线程 TA ta(7); thread mytobj2(ta); mytobj2.join(); //主线程结束ta这个对象就不在了,thread mytobj2(ta)实际上是拷贝复制一个对象,执行对象的拷贝构造函数 //注意使用detach时要注意不要将主线程的变量的指针或引用交给子线程 //2.用lambda表达式创建线程 auto mylamthread=[]&#123; cout&lt;&lt;&quot;我的线程开始执行了&quot;&lt;&lt;endl; cout&lt;&lt;&quot;我的线程结束了&quot;&lt;&lt;endl; &#125;; thread mytobj3(mylamthread); mytobj3.join(); //3.用函数创建线程 thread mytobj(myprint);//创建线程,线程执行起点myprint() //mytobj.join();//加入/汇合,阻塞主线程,让主线程等待子线程执行完毕,然后主线程开始执行 mytobj.detach();//主线程不等待子线程就结束,一旦使用detach就不能使用join会出错 if(mytobj.joinable())&#123;//f判断是否可以使用join cout&lt;&lt;&quot;joinable == true&quot;&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;&quot;joinable == false&quot;&lt;&lt;endl; &#125; cout&lt;&lt;&quot;I love china&quot;&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>并发与多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++字符串]]></title>
    <url>%2F2019%2F08%2F10%2FC-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[字符串初始化方式 char a[]=”abc” char a[]={“abc”} char a[]{“abc”} string a=”abc” string a={“abc”} string a{“abc”} 原始字符串:字符表示的就是自己,将“(”和“)”用作定界符,并使用前缀R来标识]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sed进阶]]></title>
    <url>%2F2019%2F08%2F08%2Fsed%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[一、多行命令 next命令 单行next(n)sed &#39;/header/{n ; d}&#39; data1.txt解析:匹配到header后,n命令使得数据流前进一行到达下一行,再使用d命令删除一行单行next命令会将数据流中的下一文本 行移动到sed编辑器的工作空间(称为模式空间) 多行next(N)sed &#39;/first/{ N ; s/\n/ / }&#39; data2.txt解析:匹配到first后,将下一行加入到该行进行处理注意: 多行版本的next命令会将下一文本行添加到模式空间中已有的文本后 文本行间仍然用换行符分隔符,即上下两行虽然一起处理但是仍然以换行符分隔 将单行命令放到N命令前面，并将多行命令放到N命令后面例子:1234sed &apos;s/System Administrator/Desktop User/ N#注意位置s/System\nAdministrator/Desktop\nUser/ &apos; data4.txt 解析:如果System Administrator文本出现在了数据流中的最后一行，N命令会错过它，因为没有其他行可读入到模式空间跟这行合并 多行删除命令(D)它只删除模式空间中的第一行。该命令会删除到换行符(含换行符)为止的所有字符。D命令的独特之处在于强制sed编辑器返回到脚本的起始处，对同一模式空间中的内容重新执行这些命令(它不会从数据流中读取新的文本行)例子:123sed &apos;/^$/&#123;N/pattern/D&#125;&apos; filename 解析:删除pattern前的空白行 多行打印命令(P)配合N一起使用多行打印命令(P)只打印多行模式空间中的第一行 模式空间和保持空间模式空间(pattern space)是一块活跃的缓冲区，在sed编辑器执行命令时它会保存待检查的文本保持空间(hold space)是缓冲区域,在处理模式空间中的某些行时,可以用保持空间来临时保存一些行操作保持空间命令:其中:复制=替换理解:保持空间就是一个临时变量,可以将模式空间的行储存在里面,在需要使用时用g、G或x命令将保存的字符串移回模式空间 排除命令(!)感叹号命令(!)用来排除(negate)命令，也就是让原本会起作用的命令不起作用$!N:美元符表示数据流中的最后一行文本，所以当sed编辑器到了最后一行时不执行N命令例子:反转了文本文件中原来的行sed -n &#39;{1!G ; h ; $p }&#39; data2.txt 改变流 分支分支(branch)命令b的格式如下:[address]b [label]address参数决定了哪些行的数据会触发分支命令。label参数定义了要跳转到的位置。如果没有加label参数，跳转命令会跳转到脚本的结尾。定义一个要跳转到的标签,标签以冒号开始,最多可以是7个字符长度。:label2例子:12345$ echo &quot;This, is, a, test, to, remove, commas.&quot; | sed -n &apos;&#123;&gt; :start&gt; s/,//1p&gt; /,/b start&gt; &#125;&apos; 解释:不停替换逗号(内含循环),功能与if then语句相似 测试测试命令会根据替换命令的结果跳转到某个标签，而不是根据地址进行跳转。如果替换命令成功匹配并替换了一个模式，测试命令就会跳转到指定的标签。如果替换命令未能匹配指定的模式，测试命令就不会跳转。测试命令使用与分支命令相同的格式:[address]t [label]例子:12345$ echo &quot;This, is, a, test, to, remove, commas. &quot; | sed -n &apos;&#123; &gt; :start&gt; s/,//1p&gt; t start&gt; &#125;&apos; 模式替代 &amp;符号&amp;符号可以用来代表替换命令中的匹配的模式,&amp;符号会提取匹配替换命令中指定模式的整个字符串即&amp;=pattern例子:sed ‘s/pattern/“&amp;”/‘ data给匹配的pattern加上””号 替代单独的单词sed编辑器用圆括号来定义替换模式中的子模式。你可以在替代模式中使用特殊字符来引用每个子模式。替代字符由反斜线和数字组成,数字表明子模式的位置,sed编辑器会给第一个子模式分配字符\1，给第二个子模式分配字符\2，依此类推。⚠️:当在替换命令中使用圆括号时，必须用转义字符将它们标示为分组字符而不是普通的圆括号,普通圆括号为表达式分组like this:sed &#39;s/\(System\) Administrator/\1 User/&#39;例子:12345$ echo &quot;1234567&quot; | sed &apos;&#123;&gt; :start&gt; s/\(.*[0-9]\)\([0-9]\&#123;3\&#125;\)/\1,\2/ &gt; &gt; t start&gt; &#125;&apos; 过程如下: 1234567ZHOUSIR:~ zhouqionglin$ echo 1234567 |sed -n &apos;&#123; :starts/\(.*[0-9]\)\([0-9]\&#123;3\&#125;\)/\1,\2/pt start&#125;&apos;1234,5671,234,567 some example:1.sed &#39;$!G&#39; data2.txt2.循环的例子,只保留后十行 12345sed &apos;&#123;:start$q ; N ; 11,$D b start&#125;&apos; data7.txt 3.删除了文本文件结尾的空白行 1234$ sed &apos;&#123;:start/^\n*$/&#123;$d ; N ; b start &#125; &#125;&apos; data10.txt 4.删除html标签sed &#39;s/&lt;[^&gt;]*&gt;//g&#39; data11.txt]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++的IO]]></title>
    <url>%2F2019%2F08%2F08%2FC-%E7%9A%84IO%2F</url>
    <content type="text"><![CDATA[一、输入1. cin根据接受值的变量的类型来将字符序列转换为所需类型2. cin检查输入流时跳过空白(换行符,空格,制表符)3. cin确定字符串结尾的方式:空白(制表符,空格,换行符),cin在获取字符输入时只读取一个单词,并自动在结尾加上空字符4. 使用cin&gt;&gt;array方式无法控制输入字符数不超出a数组容量5. cin&gt;&gt;string使用的是string类的友元函数6. 一次读取一行的方式: cin.getline(array_name,n,’split_symbol’)⚠️注意点: 1.返回值为cin对象2.读取(n-1)个字符,若输入超过数组容量,余下字符留在输入队列中,同时设置失效位关闭后面的输入3.自动在结尾加上空字符,不保留分界字符4.停止读取:读取指定数目字符or分界字符(默认换行符),通过分界字符确定结尾但不保存换行符,用空字符代替分界字符5.对于输入方法立即到达文件为这一情况:设置failbit6.对于输入了一个空行:不设置failbit cin.get(array_name,n)⚠️注意点: 1.返回值为cin对象2.不读取分界字符也不丢弃分界字符符,⚠️而是把它保存在输入队列中3.通过查看下一个字符是换行符还是其他字符就可以判断输入结束是因为数组容量限制还是输入结束(\n)4.读取空行是设置失效位failbit,可用cin.clear()恢复输入5.对于输入方法立即到达文件为这一情况:设置failbit6.对于输入空行:设置failbit 7.一次读取一个字符的方式: int a=cin.get() 1.读取下一个字符,任何字符都可以被读取包括(空格,制表符,换行符)2.到达文件尾时返回EOF符号常量 ostream&amp; cin.get(char&amp;)⚠️1.返回值为对象引用 2.到文件尾时不会再给参数赋值 cin&gt;&gt;char a⚠️1.将跳过换行符,空格 8.读取指定数目字符并丢弃 ostream &amp;cin.ignore(int n,char a)n:最大字符数a:输入分界符 9.其他一些istream方法cin.read(array_name,array_capicity):不会在输入后加上空字符使其成为字符串char a=cin.peek():返回输入中的下一个字符,但不抽取输入流中的字符putback():将一个字符插入到输入字符串中 10.cin&gt;&gt;int a注意点:返回值是cin对象输入数字后的换行符会留在输入队列中解决方法:1.cin.get()2.cin.get(ch) 11. getline(cin,string)结束的三个标志:1.到达文件尾2.遇到分界字符,将把分界字符从输入流中删除但不储存它3.读取的字符数达到最大允许值string::npos 二、输出1. IO类之间的关系 2. cout输出指针1.输出字符型指针时输出字符串,字符型指针有:char数组名,char类型指针,字符串2.输出其他类型的指针时,输出的是地址 3. ostream方法1.ostream&amp; operator&lt;&lt;()函数2.ostream&amp; put(char)函数cout.put(66)==&gt;输出为ascii码66的char值B3.ostream&amp; write()函数第一个参数为要显示的字符串的地址;第二个参数指出要显示多少个字符 4. 刷新输出缓冲区1.换行符发送到缓冲区后,将刷新缓冲区2.输入即将发生时刷新缓冲区3.控制符flush刷新缓冲区4.控制符endl刷新缓冲区并插入一个换行符flush(cout)cout&lt;&lt;flush 5. cout输出格式化:1.&lt;&lt;运算法将值转换为文本格式 2.控制进制 hex dec oct 3.调整字符宽度⚠️:设置仅对下一次输出有效两种格式:int width():返回字段宽度的当前设置int width(int i):设置字段宽度并返回以前的字段宽度用法:int b = cout.width(a) 4.填充字符cout.fill() 5.浮点数的显示精度 默认模式精度:显示的总位数 定点模式and科学模式精度:小数点后面的位数定点表示法:使用格式123.4来表示浮点数,而不管数字的长度科学表示法:使用格式1.23e04用法:cout.precision(n)⚠️:设置后长期有效 6.打印末尾的小数点和零cout.setf(ios_base::showpoint) 7.setf()函数⚠️:ios_base定义于std名称空间中,使用时要using std::ios_base两种格式:一.fmtflags setf(fmtflags)fmtflags是bitmask类型;一些格式常量(函数参数):二.fmtflags setf(fmtflags,fmtflags)第一个参数:所需设置的位第二个参数:指出要清除那位个人理解:第二个参数直接全清恢复全零状态,然后第一位再设置所需要的位 6. 标准控制符用法:cout&lt;&lt;标控 7. 头文件iomanip中的控制符1.setprecision(n)2.setw(n)3.setfill(char a) 三、文件IO1.包含头文件fstream2.必须指明命名空间std 将内容写入文件 ofstream fout;fout.open(filename);fouttext line;fout.close() 背记方法:将内容输入到文件类比与cout将内容输入到屏幕 读取文本文件 string a;ifstream fin;fin.open(filename);fin&gt;&gt; a;fin.close(); 检查文件是否打开 1234include&lt;cstdlib&gt;if(!fin.is_open())&#123;exit(EXIT_FAILURE)&#125; 循环输入代码1. 1234fin&gt;&gt;a;while(fin.good())&#123;fin&gt;&gt;a;&#125; 代码2. 123while(fin&gt;&gt;a)&#123; ...&#125; 原因:fin&gt;&gt;a返回值是fin对象,在需要判断时fin的结果为fin.good() 流状态由三个元素组成:eofbit,badbit,failbit流状态位被设置后流将对后面的输入或输出关闭 一、检查IO错误方法1.eof():遇到eof2.fail():读取操作类型不匹配,遇到文件尾EOF;badbit或failbit被设置3.bad():文件受损或硬件故障,文件读取错误4.good():没有发生任何错误时返回true二、设置流状态clear(iostate s):无参数时重置状态,setstate(iostate s):无参数时重置状态,有参数时该参数被设置,其他两个状态位被清除exceptions(iostate ex):设置ex位被设置,有参数时只影响参数设置的位 对于输入错误的处理代码(输入类型和要求类型不符合) 12345678char a[20];while(!cin&gt;&gt;a[i])&#123; if(cin.fail()&amp;&amp;!cin.eof())&#123; cin.clear(); while(cin.get()!=&apos;\n&apos;) continue; &#125;&#125; 文件模式]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F08%2F08%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在Linux中，有两种流行的正则表达式引擎:1.POSIX基础正则表达式(basic regular expression，BRE)引擎2.POSIX扩展正则表达式(extended regular expression，ERE)引擎 sed只支持BREgawk和awk支持ERE⚠️:1.正则表达式模式都区分大小写。这意味着它们只会匹配大小写也相符的模式2.在正则表达式中，不用写出整个单词。只要定义的文本出现在数据流中，正则表达式就能够匹配3.在正则表达式中，空格和其他的字符并没有什么区别4.不能在文本模式中单独使用.*[]^${}+?|(),如果要用某个特殊字符作为文本字符，就必须转义来告诉正则表达式引擎应该将接下来的字符当作普通的文本字符,使用反斜线5.由于反斜线是特殊字符，如果要在正则表达式模式中使用它，你必须对其转义，这样就产生了两个反斜线6.尽管正斜线不是正则表达式的特殊字符,要使用正斜线，也需要进行转义 BRE 锚字符 锁定在行首(^)如果你将^放到模式开头之外的其他位置，那么它就跟普通字符一样，不再是特殊字符了 锁定在行尾($)例子:过滤出数据流中的空白行sed &#39;/^$/d&#39; data5 点号字符(.)用来匹配除换行符之外的任意单个字符。它必须匹配一个字符，如果在点号字符的位置没有字符，那么模式就不成立 字符组([])使用方括号来定义一个字符组。方括号中包含所有你希望出现在该字符组中的字符。 排除型字符组([ ^]) 区间[n1-n2] 特殊的字符组 星号字符后面放置星号表明该字符必须在匹配模式的文本中出现0次或多次将点号特殊字符和星号特殊字符组合起来。这个组合能够匹配任意数量的任意字符星号还能用在字符组上。它允许指定可能在文本中出现多次的字符组或字符区间例子[ae]*:a和e字符以任何组合形式出现ERE 问号问号表明前面的字符可以出现0次或1次例子:[ae]?如果字符组中的字符出现了0次或1次，模式匹配就成立。但如果两个字符都出现了，或者其一个字符出现了2次，模式匹配就不成立 加号加号表明前面的字符可以出现1次或多次，但必须至少出现1次。如果该字符没有出现，那么模式就不会匹配例子[ae]+:如果字符组中定义的任一字符出现了，文本就会匹配指定的模式 花括号{n}:正则表达式准确出现n次{m,n}:正则表达式至少出现m次，至多n次注意⚠️:默认情况下，gawk程序不会识别正则表达式间隔。必须指定gawk程序的–re-interval 命令行选项才能识别正则表达式间隔。 管道符号格式:expr1|expr2|…用逻辑OR方式指定正则表达式引擎要用的两个或多个模式。如果任何一个模式匹配了数据流文本，文本就通过测试 表达式分组将正则表达式模式分组时，该组会被视为一个标准字符。可以像对普通字符一样给该组使用特殊字符like this:sat(urday)?其中urday匹配0次或1次]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sed和gawk]]></title>
    <url>%2F2019%2F08%2F07%2Fsed%E5%92%8Cgawk%2F</url>
    <content type="text"><![CDATA[sed 编辑器sed编辑器被称作流编辑器,sed编辑器可以根据命令来处理数据流中的数据，这些命令要么从命令行中输入，要么存储在一个命令文本文件中sed编辑器会执行下列操作:(1) 一次从输入中读取一行数据。(2) 根据所提供的编辑器命令匹配数据。(3) 按照命令修改流中的数据。(4) 将新的数据输出到STDOUT。sed命令的格式如下:sed options script filesed编辑器并不会修改文本文件的数据。它只会将修改后的数据发送到STDOUT ###1. 在命令行使用多个编辑器命令使用-e选项sed -e &#39;s/brown/green/; s/dog/cat/&#39; data1.txt⚠️:命令之间必须用分号隔开，并且在命令末尾和分号之间不能有空格。 ###2. 从文件中读取编辑器命令用-f选项来指定文件来读取命令不用在每条命令后面放一个分号。sed编辑器知道每行都是一条单独的命令 ###3. 命令 ####一、s命令功能：替换功能,但默认情况下它只替换每行中出现的第一处格式：s/string/string/1.替换标记：让替换命令能够替换一行中不同地方出现的文本格式：s/pattern/replacement/flags有4种可用的替换标记flags: 数字，表明新文本将替换第几处模式匹配的地方; g，表明新文本将会替换所有匹配的文本; p，配合-n选项一起使用，只输出被替换命令修改过的行 w file，将替换的结果写到文件中，只将哪些可以匹配的被处理过的行写入文件，其显示和p配合-n选项一样 2.字符串分隔符不一定一定要使用s/string_a/string_b/，也可以s!string_a!string_b! ####二、d命令功能:删除行1.删除特定行sed ‘nd’ filenamesed ‘n1,n2d’ filenamesed ‘n1,$d’ filenamesed ‘/pattern/d’ filename ####三、i命令 and a命令插入(insert)命令(i)会在指定行前增加一个新行附加(append)命令(a)会在指定行后增加一个新行格式： '[address]command\1new line&apos; filename ⚠️:必须在sed命令中单独指定新行such as 12sed &apos;ni\new line&apos; filename 123sed &apos;$i\new line1\new line2&apos; filename ####四、c命令修改(change)命令允许修改数据流中整行文本的内容格式和i and s命令一样such as 12sed &apos;/pattern/c\the change line&apos; filenname #####五、y命令转换(transform)命令(y)是唯一可以处理单个字符的sed编辑器命令格式:[address]y/inchars/outchars/换命令会对inchars和outchars值进行一对一的映射。inchars中的第一个字符会被转换为outchars中的第一个字符，第二个字符会被转换成outchars中的第二个字符。这个映射过程会一直持续到处理完指定字符。⚠️ ：1.inchar和outchar必须等长2.转换命令是一个全局命令，也就是说，它会文本行中找到的所有指定字符自动进行转换，而不会考虑它们出现的位置。 ####六、p and = and l命令 p命令用来打印文本行; 等号(=)命令用来打印行号; l(小写的L)命令用来列出行。 p命令例子:1234$ sed -n &apos;/3/&#123;&gt; p&gt; s/line/test/p&gt; &#125;&apos; data6.txt 2.=命令等号命令会打印行在数据流中的当前行号。行号由数据流中的换行符决定例子:让sed编辑器只显示包含匹配文本模式的行的行号和文本 1234$ sed -n &apos;/pattern/&#123; &gt; =&gt; p&gt; &#125;&apos; data6.txt l命令打印特殊字符####七、w命令用来向文件写入行格式:[address]w filename####八、r命令功能:将一个独立文件中的数据插入到数据流中,sed编辑器会将文件中的文本插入到指定地址后。格式:[address]r filename地址区间，只能指定单独一个行号或文本模式地址例子：利用另一个文件中的数据来替换文件中的占位字符1234sed &apos;/LIST/&#123;r data11.txtd&#125;&apos; notice.std 解析：data11内容替换notice.std中的list占位符,并删除占位符 ####九、q命令退出{} ###5. 使用地址如果只想将命令作用于特定行或某些行，则必须用行寻址两种形式的行寻址 ####1.以数字形式表示行区间sed ‘n1,n2s/string1/string2/‘ filenamesed ‘ns/string1/string2/‘ filename(其中n为数字)sed ‘n,$/string1/string2/‘ filename ####2.用文本模式来过滤出行格式:/pattren/commandsuch as sed &#39;/pattern_string/s/string1/string2/&#39; filename必须用正斜线将要指定的pattern封起来。sed编辑器会将该命令作用到包含指定文本模式的行上 ####3.两种方法组合例子:/pattern/,$!d ####4.命令组合格式： 12345address &#123; command1 command2 command3 &#125; such as: 1234$ sed &apos;2&#123;&gt; s/fox/elephant/&gt; s/dog/cat/&gt; &#125;&apos; data1.txt gawk 程序 定义变量来保存数据; 使用算术和字符串操作符来处理数据; 使用结构化编程概念(比如if-then语句和循环)来为数据处理增加处理逻辑; 通过提取数据文件中的数据元素，将其重新排列或格式化，生成格式化报告。gawk程序的基本格式如下:gawk options program file ###1. 从命令行读取程序脚本gawk程序脚本用一对花括号来定义。你必须将脚本命令放到两个花括号({})中。由于gawk命令行假定脚本是单个文本字符串，你还必须将脚本放到单引号中。like this gawk &#39;{print &quot;Hello World!&quot;}&#39;gawk程序会从STDIN接收数据,gawk程序会针对数据流中的每行文本执行程序脚本要终止这个gawk程序,Ctrl+D组合键会在bash中产生一个EOF字符。这个组合键能够终止该gawk程序并返回到命令行界面提示符下 ###2. 使用数据字段变量gawk会自动给一行中的每个数据元素分配一个变量,每个数据字段都是通过字段分隔符划分的。gawk在读取一行文本时，会用预定 义的字段分隔符划分每个数据字段。gawk中默认的字段分隔符是任意的空白字符(例如空格或制表符) $0代表整个文本行; $1代表文本行中的第1个数据字段; $2代表文本行中的第2个数据字段; $n代表文本行中的第n个数据字段。注意使用-F来指定IFS###3. 在程序脚本中使用多个命令在命令行上的程序脚本中使用多条命令，只要在命令之间放个分号即可###4. 从文件中读取程序使用-f选项可以在程序文件中指定多条命令。要这么做的话，只要一条命令放一行即可可以在文件中定义了一个叫作FS的特殊变量。这是定义字段分隔符的另一种方法，这样你就不用依靠脚本用户在命令行选项中定义字段分隔符了###5. 在处理数据前运行脚本默认情况下，gawk会从输入中读取一行文本，然后针对该行的数据执行程序脚本。有时可能需要在处理数据前运行脚本，比如为报告创建标题。BEGIN 关键字就是用来做这个的。它会强制gawk在读取数据前执行BEGIN关键字后指定的程序脚本gawk &#39;BEGIN {print &quot;The data3 File Contents:&quot;} {print $0}&#39; data3.txt###6. 在处理数据后运行脚本END关键字允许你指定一个程序脚本，gawk会在读完数据后执行它gawk &#39;BEGIN {print &quot;The data3 File Contents:&quot;}{print $0} END{print &quot;End of File&quot;}&#39; data3.txt]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习]]></title>
    <url>%2F2019%2F08%2F06%2Fgit%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Git 初始化及仓库创建和操作Git 本地操作 基本信息设置 设置用户名git config --global user.name github用户名 设置用户名邮箱git config --global user.email github邮箱 初始化一个新的Git仓库mkdir work_directorycd work_directorygit init会产生一个.git文件 向仓库添加文件在工作区生成文件后将文件提交到暂存区git add filename+git status将在暂存区文件提交到git仓库git commit -m &#39;add filename&#39; 修改仓库文件第一步修改文件vim filename第二步git add对比文件差异git diff 文件名#工作区和暂存区对比git diff 本地库历史版本 文件名#工作区文件和本地库历史记录对比 删除文件 删除本地库文件 删除文件rm filename 从git中删除文件git rm filename 提交操作git commit -m &#39;提交描述&#39; 2.删除提交到暂存区，取消删除，找回文件git reset –hard 被删除文件创建时的索引删除文件找回前提：删除前文件已经提交到本地库 分支操作 创建分支 git branch 分支名 查看分支 git branch -v 切换分支 git checkout 分支名 合并分支 1.切换到接收修改的分支 git checkout 被合并分支名2.执行merge命令 git merge 有新内容的分支名 合并时冲突产生：两个分支同时修改同一个文件同一行 解决冲突：vim 冲突文件可以看到冲突表现git add 冲突文件git commit -m “啪啪啪” #不带文件名 查看历史记录即显示git loggit log –onelinegit log –pretty=oneline#只显示过去git reflog#当前版本移动需要几步 版本前进后退 基于索引git reset –hard 索引值 使用^git reset –hard HEAD^#后退一步 使用～git reset –hard HEAD ~n步数 reset命令三个参数对比–soft仅仅在本地库移动HEAD指针–mixed在本地库移动HEAD指针重置暂存区–hard在本地库移动HEAD指针重置暂存区重置工作区 Git管理远程仓库 创建远程仓库别名git remote -v 查看当前所有远程地址别名git remote add [远程库地址别名] [远程地址] Git推送操作将本地仓库同步到远程仓库将git push [远程库地址别名] [分支名]git push &lt;远程主机名&gt; &lt;本地分支名&gt; &lt;远程分支名&gt; Git克隆操作 目的将远程仓库(github对应项目)复制到本地 代码git clone 仓库地址 效果 1.完整的把远程库下载到本地2.创建origin远程地址别名3.初始化本地仓库 Git拉取操作pull=fetch+mergegit fetch [远程库地址别名 远程分支名]git merge [远城地址别名/远程分支名]git pull [远程库地址别名] [远程分支名] 解决冲突 如果不是基于GitHub远程库的最新版所做的修改，不能推送，必须先拉取。 拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即可。 Git 基本原理 哈希 一些问题的解决12345678To https://github.com/Jackzhou1999/test_git.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to &apos;https://github.com/Jackzhou1999/test_git.git&apos;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 本地没有update到最新版本的项目解决git pull --rebase origin master]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形化桌面环境中的脚本]]></title>
    <url>%2F2019%2F08%2F06%2F%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[使用case in 语句 select命令只需要一条命令就可以创建出菜单，然后获取输入的答案并自动处理。select 命令的格式如下1234select variable in listdo commandsdone list参数是由空格分隔的文本选项列表，这些列表构成了整个菜单。select命令会将每个列表项显示成一个带编号的选项，然后为选项显示一个由PS3环境变量定义的特殊提示符。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux脚本函数]]></title>
    <url>%2F2019%2F08%2F06%2FLinux%E8%84%9A%E6%9C%AC%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[创建函数格式一:123function name &#123; commands&#125; 格式二: 123name() &#123; commands &#125; 使用函数在行中指定函数名⚠️1.函数在使用之前要定义，否则报错2.函数名要唯一，出现重复的话使用最后定义的函数 返回值1.默认退出状态码$?⚠️:使用退出状态码无法确定函数内的指令是否全部执行成功2.使用return命令⚠️:1.函数一结束立即用$?获取返回值，如果在用$?变量提取函数返回值之前执行了其他命令，函数的返回值就会丢失2.退出状态码必须是0~2553.使用$()获取函数的输出(very important)12345function dbl &#123; read -p &quot;Enter a value: &quot; value echo $[ $value * 2 ]&#125;result=$(dbl) 注意只提取echo的stdout，read的提示信息不提取这种方法可以返回字符串和浮点数 向函数传递参数格式:fuction_name val1 val2 val3bash shell会将函数当作小型脚本来对待，函数可以使用标准的参数环境变量来表示命令行上传给函数的参数$0:函数名$1-9:$#:函数的参数数目但是由于函数使用特殊参数环境变量作为自己的参数值，因此它无法直接获取脚本在命令行中的参数值⚠️:函数中使用的$1和$2变量和脚本主体中的$1和$2变量并不相同,要在函数中使用这些值，必须在调用函数时手动将它们传过去。 在函数中处理变量 全局变量默认情况下，你在脚本中定义的任何变量都是全局变量（fuck)。在函数外定义的变量可在函数内正常访问 局部变量在变量声明的前面加上local关键字，local关键字保证了变量只局限在该函数中 数组变量和函数 将数组传给函数如果你试图将该数组变量作为函数参数，函数只会取数组变量的第一个值。要解决这个问题，必须将该数组变量的值分解成单个的值，然后将这些值作为函数参数使用。在函数内部，可以将所有的参数重新组合成一个新的变量1234567#/bin/bashfunction test &#123;local new_arrayecho=(`echo $@`)&#125;array=(1 2 3 4 5)#注意数字之间为spacetest $&#123;array[*]&#125; 背记两种数组的复制方式a=(1 2 3 4)1.array=反单引号 echo ${a[]} 反单引号2.array=$( echo ${a[]} )背记两种计算方法1.var=$((计算表达式))2.var=$[计算表达式]#注意空格 从函数传出数组在函数中把数组拆开后返回123456function test&#123;local array=(1 2 3 4)echo $&#123;a[*]&#125;&#125;var=$(test) 函数递归⚠️函数内的变量一定要是局部变量 创建函数库 第一步是创建一个包含脚本中所需函数的公用库文件 下一步是在用到这些函数的脚本文件中包含库文件注意作用域：脚本文件和函数库文件的作用域要相同解决方法:可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。source filename# filename必须是可执行的脚本文件或者. filename# 注意“.”号后面还有一个空格 在命令行上使用函数 在命令行上创建函数方法一、当在命令行上定义函数时，你必须记得在每个命令后面加个分号，这样shell就能知道在哪里是命令的起止了方法二、是采用多行方式来定义函数。在定义时，bash shell会使用次提示符来提示输入更 多命令。用这种方法，你不用在每条命令的末尾放一个分号，只要按下回车键就行。 在.bashrc文件中定义函数方法一、直接在文件内定义函数方法二、使用source将函数库文件导入.bashrc,要确保库文件的路径名正确，以便bash shell能够找到该文件]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[控制脚本]]></title>
    <url>%2F2019%2F08%2F05%2F%E6%8E%A7%E5%88%B6%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Linux信号 Linux信号![](Linux 控制信号2.png) 生成信号 中断进程Ctrl+C 暂停进程Ctrl+Zshell将shell中运行的每个进程称为作业， 并为每个作业分配唯一的作业号。它会给第一个作业分配作业号1，第二个作业号2，以此类推可以用ps命令来查看已停止的作业,在S列中(进程状态)，ps命令将已停止作业的状态为显示为T。这说明命令要么被跟踪，要么被停止了 捕获信号trap命令允许你来指定shell 脚本要监看并从shell中拦截的Linux信号。如果脚本收到了trap命令中列出的信号，该信号不再 由shell处理，而是交由本地处理格式为:trap commands signals在trap命令行上，你只要列出想要shell执行的命令，以及一组用空格分开的待捕获的信号。你可以用数值或Linux信号名来指定信号。 捕获脚本退出在shell完成任务时 执行命令的一种简便方法trap &quot;echo Goodbye...&quot; EXIT 修改或移除捕获要想在脚本中的不同位置进行不同的捕获处理，只需重新使用带有新选项的trap命令,修改了信号捕获之后，脚本处理信号的方式就会发生变化。但如果一个信号是在捕获被修改 前接收到的，那么脚本仍然会根据最初的trap命令进行处理。也可以删除已设置好的捕获。只需要在trap命令与希望恢复默认行为的信号列表之间加上两个破折号就行了,like thistrap &quot;echo &#39; Sorry... Ctrl-C is trapped.&#39;&quot; SIGINT+trap --SIGINT以后台模式运行脚本在后台模式中， 进程运行时不会和终端会话上的STDIN、STDOUT以及STDERR关联 后台运行脚本在命令后加个&amp;符,⚠️最好是将后台运行的脚本的STDOUT和STDERR进行重定向输出在非控制台下运行脚本nohup命令:让脚本一直以后台模式运行到结束，即使你退出了终端会话,nohup命令运行了另外一个命令来阻断所有发送给该进程的SIGHUP信号,这会在退出终端会话时阻止进程退出格式为:nohup ./test1.sh &amp;由于nohup命令会解除终端与进程的关联，进程也就不再同STDOUT和STDERR联系在一起。为了保存该命令产生的输出，nohup命令会自动将STDOUT和STDERR的消息重定向到一个名为 nohup.out的文件中。作业控制启动、停止、终止以及恢复作业的这些功能统称为作业控制作业控制中的关键命令是jobs命令。jobs命令允许查看shell当前正在处理的作业。要想查看作业的PID，可以在jobs命令中加入-l选项 重启停止的作业bg命令加上作业号定时运行作业at命令允许指定Linux系统何时运行脚本。at命令会将作业提交到队列中，指定shell何时运行该作业。at的守护进程atd会以后台模式运行，检查作业队列来运行作业。大多数Linux发行版会在启动时运行此守护进程。atd守护进程会检查系统上的一个特殊目录(通常位于/var/spool/at)来获取用at命令提交的作业。默认情况下，atd守护进程会每60秒检查一下这个目录。有作业时，atd守护进程会检查作业设置运行的时间。如果时间跟当前时间匹配，atd守护进程就会运行此作业。 设置定时运行命令格式:at [-f filename] time 获取输出注意⚠️:Linux系统会将提交该作业的用户的电子邮件地址作为STDOUT和STDERR,so因此在使用at命令时，最好在脚本中对STDOUT和STDERR进行重定向,如果不想在at命令中使用邮件或重定向，最好加上-M选项来屏蔽作业产生的输出信息 列出等待的作业atq 删除作业atrm 作业号 安排需要定期执行的脚本 cron时间表min hour dayofmonth month dayofweek commandsuch as 15 16 * * 1 command#每周一4:15 PM运行的命令00 12 * * * if [date +%d -d tomorrow= 01 ] ; then ; command #设置一个在每个月的最后一天执行的命令注意⚠️： 1.命令列表必须指定要运行的命令或脚本的全路径名2.你必须有访问该命令和命令中指定的 输出文件的权限。 构建cron时间表crontab -l 预配置的cron脚本目录/etc/cron.*ly anacron程序这个功能常用于进行常规日志维护的脚本。如果系统在脚本应该运行的时间刚好关机， 日志文件就不会被整理，可能会变很大。通过anacron，至少可以保证系统每次启动时整理日 志文件]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脚本实例]]></title>
    <url>%2F2019%2F08%2F05%2F%E8%84%9A%E6%9C%AC%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[案例一、12345678910#!/bin/bash # read file and create INSERT statements for MySQL outfile=&apos;members.sql&apos; IFS=&apos;,&apos; while read lname fname address city state zip do cat &gt;&gt; $outfile &lt;&lt; EOFINSERT INTO members (lname,fname,address,city,state,zip) VALUES (&apos;$lname&apos;, &apos;$fname&apos;, &apos;$address&apos;, &apos;$city&apos;, &apos;$state&apos;, &apos;$zip&apos;);EOFdone &lt; $&#123;1&#125; 理解知识点: cat &gt; $outfile 命令用于连接文件并打印到标准输出设备上(打开outfile文件并将标准输入重定向到outfile文件中） &lt;&lt;EOF 内容 EOF:将内容作为标准输出 案例二、1234567891011121314151617181920212223#/bin/bashcount=0echo $PATHfor i in $(echo $PATH | sed &apos;s/:/ /g&apos;)do count=$[ $count + 1 ] echo $count &quot;In the directory:&quot; $i files=$(ls $i) count2=0 cd $i for j in $files do if [ -f &quot;$j&quot; ];then #echo &quot;-------&quot; $j count2=$(($count2 + 1)) fi done echo &quot;there are $count2 file in the $i&quot; cd -doneecho $count 统计文件个数 案例三、~~~~~~~~~~~~~~~~~~~~~“count.sh” 23L, 392C 1,1 全部]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将脚本的输出重定向到Linux系统的不同位置]]></title>
    <url>%2F2019%2F08%2F04%2F%E5%B0%86%E8%84%9A%E6%9C%AC%E7%9A%84%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%8D%E5%90%8C%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[标准文件描述符Linux用文件描述符(file descriptor)来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。 重定向错误 只重定向错误2&gt; 重定向错误和数据&amp;&gt; 在脚本中重定向输出 临时重定向行输出 永久重定向脚本中的所有命令 1.临时重定向echo &quot;This is an error&quot; &gt;&amp;22.永久重定向用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符exec 1&gt;filename 在脚本中重定向输入exec命令允许你将STDIN重定向到Linux系统上的文件中:exec 0&lt; testfile将STDIN重定向到文件后， 当read命令试图从STDIN读入数据时，它会到文件去取数据，而不是键盘 创建自己的重定向在shell 中最多可以有9个打开的文件描述符。其他6个从3~8的文件描述符均可用作输入或输出重定向exec 3&gt;test13out+&gt;&amp;3创建新文件来将输出追加到现有文件中 永久重定向恢复恢复已重定向的文件描述符123exec 3&gt;&amp;1exec 1&gt;test14outexec 1&gt;&amp;3 ⚠️背记exec的第二个参数要加&amp;,第一个不用加 将文件描述符同时用于输入和输出可以打开单个文件描述符来作为输入和输出。可以用同一个文件描述符对同一个文件进行读写exec 3&lt;&gt; testfile⚠️⚠️由于是对同一个文件进行数据读写，shell会维护一个内部指针，指明在文件中的当前位置。任何读或写都会从文件指针上次的位置开始。 关闭文件描述符要关闭文件描述符，将它重定向到特殊符号&amp;-;一旦关闭了文件描述符，就不能在脚本中向它写入任何数据，否则shell会生成错误消息exec 3&gt;&amp;- 列出打开的文件描述符lsof命令会列出整个Linux系统打开的所有文件描述符普通用户账户来运行它，必须通过全路径名来引用:$ /usr/sbin/lsof该命令会产生大量的输出。它会显示当前Linux系统上打开的每个文件的有关信息。这包括 后台运行的所有进程以及登录到系统的任何用户 -p选项允许指定进程-d选项允许指定要显示的文件描述符编号-a选项用来对其他两个选项的结果执行布尔AND运算， 进程的当前PID，可以用特殊环境变量$$查看 阻止命令输出将STDERR重定向到一个叫作null文件的特殊文件。null文件跟它的名字很像，文件里什么都没有。shell输出到null文件的任何数据都不会保存,全部都被丢掉了 空文件的技巧:也可以在输入重定向中将/dev/null作为输入文件。由于/dev/null文件不含有任何内容,通常用它来快速清除现有文件中的数据,而不用先删除文件再重新创建。cat /dev/null &gt; filename文件filename仍然存在系统上，但现在它是空文件。这是清除日志文件的一个常用方法,因为日志文件必须时刻准备等待应用程序操作 创建临时文件Linux使用/tmp目录来存放不需要永久保留的文件。大多数Linux发行版配置了系统在启动时自动删除/tmp目录的所有文件mktemp命令可以在/tmp目录中创建一个唯一的临时 文件。shell会创建这个文件，但不用默认的umask值(参见第7章)。它会将文件的读和写权限分配给文件的属主,并将你设成文件的属主。一旦创建了文件,你就在脚本中有了完整的读写权限,但其他人没法访问它(当然,root用户除外) 创建本地临时文件默认情况下，mktemp会在本地目录中创建一个文件用法:mktemp testing.XXXXXX #文件名模板+6个Xmktemp命令的输出正是它所创建的文件的名字,所以可以这样将文件名储存在变量中tempfile=$(mktemp test19.XXXXXX) 在/tmp目录创建临时文件 -t选项会强制mktemp命令来在系统的临时目录来创建该文件，在用这个特性时，mktemp命令会返回用来创建临时文件的全路径，而不是只有文件名 创建临时目录 -d选项告诉mktemp命令来创建一个临时目录而不是临时文件 记录信息tee:将输出同时发送到显示器和日志文件tee命令将从STDIN过来的数据同时发往两处。一处是 STDOUT，另一处是tee命令行所指定的文件名tee filename默认将覆盖filename，使用-a选项可以改成追加模式]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux脚本编程2]]></title>
    <url>%2F2019%2F08%2F04%2FLinux%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B2%2F</url>
    <content type="text"><![CDATA[处理用户输入 位置参数:$0是程序名，$1是第 一个参数，$2是第二个参数，依次类推，直到第九个参数$9 每个参数都是用空格分隔的 如果脚本需要的命令行参数不止9个，你仍然可以处理，但是需要稍微修改一下变量名。在第9个变量之后，你必须在变量数字周围加上花括号，比如${10} $0参数获取shell在命令行启动的脚本名,but123bash test.sh ==&gt; $0=test.sh./test.sh ==&gt; $0=./test.shbash /home/Christine/test5.sh ==&gt; $0=/home/Christine/test5.sh 如果要编写一个根据脚本名来执行不同功能的脚本，就得做点额外工作。得把脚本的运行路径给剥离掉。另外,还要删除与脚本名混杂在一起的命令将脚本名从路径中提取出:basename命令会返回不包含路径的脚本名⚠️技巧:用-ne测试命令行参数数量。如果参数数量不对，会显示一条错误消息告知脚本的正确用法 特殊参数变量: $#含有脚本运行时携带的命令行参数的个数 1$&#123;!#&#125; 就代表了最后一个命令行参数变量,当命令行上没有任何参数时,$#的值为0,params变量的值也一样,但该变量会返回命令行用到的脚本名 $*变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每一个参数值。基本上$*变量会将这些参数视为一个整体,而不是多个个体。 $@变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。这样就能够遍历所有的参数值，得到每个参数,这通常通过for命令完成 移动变量:使用shift命令时,默认情况下它会将每个参数变量向左移动一个位置。所以,变量$3的值会移到$2中,变量$2的值会移到$1中,而变量$1的值则会被删除(注意,变量$0的值,也就是程序名,不会改变)⚠️技巧:在不知道到底有多少参数时,可以只操作第一个参数,移动参数,然后继续操作第一个参数;使用shift命令的时候要小心。如果某个参数被移出,它的值就被丢弃了,无法再恢复。🌰: 123456while [ -n &quot;$1&quot; ] do echo &quot;Parameter #$count = $1&quot; count=$[ $count + 1 ] shiftdone 处理选项:用case语句来判断选项 12345678910while [ -n &quot;$1&quot; ]do case &quot;$1&quot; in -a) echo &quot;Found the -a option&quot; ;; -b) echo &quot;Found the -b option&quot; ;; -c) echo &quot;Found the -c option&quot; ;; *) echo &quot;$1 is not an option&quot; ;; esacshift done 分离参数和选项 123456789101112while [ -n &quot;$1&quot; ]do case &quot;$1&quot; in -a) echo &quot;Found the -a option&quot; ;; -b) echo &quot;Found the -b option&quot;;; -c) echo &quot;Found the -c option&quot; ;; --) shift #划重点 break ;; *) echo &quot;$1 is not an option&quot;;; esacshiftdone ⚠️“–”号后面是参数,such as 输入 “$ ./test16.sh -c -a -b – test1 test2 test3” 处理带值的选项处理的输入like this “$ ./testing.sh -a test1 -b -c -d test2” 1234567891011121314while [ -n &quot;$1&quot; ]do case &quot;$1&quot; in -a) echo &quot;Found the -a option&quot;;; -b) param=&quot;$2&quot; echo &quot;Found the -b option, with parameter value $param&quot; shift ;;#划重点 -c) echo &quot;Found the -c option&quot;;; --) shift break ;; *) echo &quot;$1 is not an option&quot;;; esacshift#划重点done 处理合并选项:getopt命令可以接受一系列任意形式的命令行选项和参数，并自动将它们转换成适当的格式命令格式如下：getopt optstring parameters在optstring中列出要在脚本中用到的每个命令行选项字母。然后，在每个需要参数值的选项字母后加一个冒号。getopt命令会基于定义的optstring解析提供的参数。such as “getopt ab:cd -a -b test1 -cd test2 test3”#其中选项b需要一个参数值，默认插入双破折线--来分隔行中的额外参数如果指定了一个不在optstring中的选项，默认情况下，getopt命令会产生一条错误消息,如果想忽略这条错误消息，可以在命令后加-q选项。 在脚本中使用getopt在脚本中加入set -- $(getopt -q optstring &quot;$@&quot;)such as:set – $(getopt ab:cd: -a test1 -b test2 -c -d test4)echo $@ -a -b test2 -c -d test4 – test1getopt命令并不擅长处理带空格和引号的参数值。它会将空格当作参数分隔符，而不是根据双引号将二者当作一个参数 在脚本中使用getopts与getopt不同，前者将命令行上选项和参数处理后只生成一个输出，而getopts命令能够和已有的shell参数变量配合默契optstring值类似于getopt命令中的那个。有效的选项字母都会列在optstring中，如果选项字母要求有个参数值，就加一个冒号。要去掉错误消息的话，可以在optstring之前加一个冒号。getopts命令将当前参数保存在命令行中定义的variable中。getopts命令会用到两个环境变量。 如果选项需要跟一个参数值，OPTARG环境变量就会保存这个值。 OPTIND环境变量保存了参数列表中getopts正在处理的参数位置 123456789while getopts :ab:c optdo case &quot;$opt&quot; in a) echo &quot;Found the -a option&quot; ;; b) echo &quot;Found the -b option, with value $OPTARG&quot;;; c) echo &quot;Found the -c option&quot; ;; *) echo &quot;Unknown option: $opt&quot;;;esac done getopts命令解析命令行选项时会移除开头的单破折线，所以在case定义中不用单破折线getopts命令的几个好用的功能:1.可以在参数值中包含空格($ ./test19.sh -b “test1 test2” -a)2.将选项字母和参数值放在一起使用，而不用加空格。($ ./test19.sh -abtest1)3.getopts还能够将命令行上 找到的所有未定义的选项统一输出成问号 从文件中读取数据 123456count=1cat test | while read line do echo &quot;Line $count: $line&quot; count=$[ $count + 1]done 可以用read命令来读取Linux系统上文件里保存的数据。每次调用read命令,它都会从文件中读取一行文本。当文件中再没有内容时,read命令会退出并返回非零退出状态码。将文件中的数据传给read命令。最常见的方法是对文件使用cat命令将结果通过管道直接传给含有read命令的while命令 总结： bash shell提供了三种方式来处理命令行选项。第一种方式是将它们像命令行参数一样处理。可以利用位置参数变量来遍历选项，在每个选项出现在命令行上时处理它。另一种处理命令行选项的方式是用getopt命令。该命令会将命令行选项和参数转换成可以 在脚本中处理的标准格式。getopt命令允许你指定将哪些字母识别成选项以及哪些选项需要额 外的参数值。getopt命令会处理标准的命令行参数并按正确顺序输出选项和参数。处理命令行选项的最后一种方法是通过getopts命令(注意是复数)。getopts命令提供了 处理命令行参数的高级功能。它支持多值的参数，能够识别脚本未定义的选项。 3种不同的方法来从脚本用户处获得数据。命令行参数允许用户运行脚本时直接从命令行输入数据。脚本通过位置参数来取回命令行参数并将它们赋给变量。shift命令通过对位置参数进行轮转的方式来操作命令行参数。就算不知道有多少个参数， 这个命令也可以让你轻松遍历参数。除了参数外，脚本用户还可以用命令行选项来给脚本传递信息。命令行选项是前面带有单破折线的单个字母。可以给不同的选项赋值，从而改变脚本的行为]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux脚本编程]]></title>
    <url>%2F2019%2F07%2F30%2FLinux%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[变量 如果要给变量赋一个含有空格的字符串值，必须用单引号来界定字符串的首和尾 如果要用到变量，使用$;如果要操作变量，不使用$，这条规则的一 个例外就是使用printenv显示某个变量的值;引用一个变量值时需要使 用美元符，而引用变量来对其进行赋值时则不要使用美元符$ 子shell无法使用export命令改变父shell中全局环境变量的值,在子进程中删除了一个全局环境变量,这只对子进程有效,该全局环境变量在父进程中依然可用 子shell可以继承父shell导出过的变量。 举例来说，如果父shell是登录shell，在/etc/profile、/etc/profile.d/*.sh和$HOME/.bashrc文件中设置并导出了变量，用于执行脚本的子shell就能够继承这些变量。要记住，由父shell设置但并未导出的变量都是局部变量，子shell无法继承局部变量。 存储个人用户永久性bash shell变量的地方是$HOME/.bashrc文件 要给某个环境变量设置多个值，可以把值放在括号里，值与值之间用空格分隔🌰:mytest=(one two three four five)⚠️ :环境变量数组的索引值都是从零开始 用户变量可以是任何由字母、数字或下划线组成的文本字符串，长度不超过20个。用户变量 区分大小写,使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格 零碎知识点 在创建shell脚本文件时，必须在文件的第一行指定要使用的shell。其格式为: #!/bin/bash 命令替换(从命令输出中提取信息，并将其赋给变量):法一、反引号字符;法二、$()格式 重定向输入和输出:输出重定向将命令的输出发送到一个文件中。bash shell用大于号(&gt;)来完成这项功能,如果输出文件已经存在了，重定向操作符会用新的文件数据覆盖已有文件,在这种情况下，可以用双大于号(&gt;&gt;)来追加数据;输入重定向将文件的内容重定向到命令，而非将命令的输出重定向到文件 管道(|):将命令输出重定向到另一个命令。这个过程叫作管道连接(piping) 在bash中，在将一个数学运算结果赋给某个变量时，可以用美元符和方括号($[ operation ])或( $((operation)) )将数学表达式围起来 bash shell数学运算符只支持整数运算。若要进行任何实际的数学计算，这是一个巨大的限制🌰:var3=$(echo “scale=4; $var1 / $var2” | bc)bc命令能识别输入重定向，允许你将一个文件重定向到bc命令来处理;使用内联输入重定向，它允许直接在命令行中重定向数据。在shell脚本中可以将输出赋给一个变量🌰12345variable=$(bc &lt;&lt; EOFoptionsstatementsexpressionsEOF ) 1234567var5=$(bc &lt;&lt; EOF scale = 4 a1 = ( $var1 * $var2) b1 = ($var3 * $var4) a1 + b1 EOF ) 变量$?来保存上个已执行命令的退出状态码 一个成功结束的命令的退出状态码是0。如果一个命令结束时有错误，退出状态 码就是一个正数值 。exit命令允许你在脚本结束时指定一 个退出状态码 文件名中没有加入路径,这要求文件和脚本位于同一个目录中,如果不是的话,需要使用全路径名(不管是绝对路径还是相对路径)来 引用文件位置 结构化命令一、IF THEN总的If then结构一、if-then语句 (if-then语句不能测试命令退出状态码之外的条件) 1234if command then commands fi 或者 123if command; then commands fi Bash shell的if语句会运行if后面的那个命令。如果该命令的退出状态码是0 (该命令成功运行)，位于then部分的命令就会被执行。如果该命令的退出状态码是其他值，then 部分的命令就不会被执行，bash shell会继续执行脚本中的下一个命令。fi语句用来表示if-then 语句到此结束。二、if-then-else语句 123456if command then commands else commands fi 三、嵌套if语句 command1 123456then commands elif command2 then more commands fi elif语句行提供了另一个要测试的命令，这类似于原始的if语句行。如果elif后命令的退 出状态码是0，则bash执行第二个then语句部分的命令。⚠️bash shell会依次执行if语句， 只有第一个返回退出状态码0的语句中的then部分会被执行 If 和 then 之间的判断语句一、test命令test命令可以判断三类条件: * 数值比较 * 字符串比较 * 文件比较基本格式1 1234if test condition then commands fi test condition test命令提供了在if-then语句中测试不同条件的途径 ,如果test命令中列出的条件成立,test命令就会退出并返回退出状态码0基本格式2（无需在if-then 语句中声明test 命令） 1234if [ condition ] then commands fi 方括号定义了测试条件。注意，第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。 1.数值比较 2.字符串比较 ⚠️大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名; ⚠️大于和小于顺序和sort命令所采用的不同:比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII数值来决定排序结果。sort 命令使用的是系统的本地化语言设置中定义的排序顺序。对于英语，本地化设置指定了在排序顺 序中小写字母出现在大写字母前MOTHER FUCKER:test命令和测试表达式使用标准的数学比较符号来表示字符串比较，而用文本代码来表 示数值比较。3.文件比较⚠️if [ -d “$file” ]在Linux中,目录名和文件名中包含空格当然是合法的。要适应这种情况,应该将$file变量用双引号圈起来。如果不这么做，遇到含有空格的目录名或文件名时就会有错误产生。⚠️理解-G比较会检查文件的默认组，如果它匹配了用户的默认组，则测试成功。二、复合条件测试if-then语句允许使用布尔逻辑来组合测试 [ condition1 ] &amp;&amp; [ condition2 ] [ condition1 ] || [ condition2 ]三、使用双括号双括号命令允许在比较过程中使用高级数学表达式双括号命令的格式为(( expression ))其中expression可以是任意的数学赋值或比较表达式⚠️不需要将双括号中表达式里的大于号转义🌰:123456#!/bin/bashval1=10if (( $val1 ** 2 &gt; 90 )) then (( val2 = $val1 ** 2 ))#赋值语句居然可以这样😏 echo &quot;The square of $val1 is $val2&quot;fi 四、使用双方括号双方括号命令提供了针对字符串比较的高级特性。双方括号里的expression使用了test命令中采用的标准字符串比较。但它提供了test命令未提供的另一个特性——模式匹配 二、CASE语句12345case variable inpattern1 | pattern2) commands1;;pattern3) commands2;;*) default commands;;esac 可以通过竖线操作符在一行中分隔出多个模式模式。星号会捕获所有与已知模式不匹配的值 三、FOR循环for命令的基本格式 1234for var in listdo commandsdone 1. 读取列表中的值🌰:for test in Alabama Alaska Arizona Arkansas California Colorado而且在for循环结束后test变量依然可以使用，$test变量的值会在shell脚本的剩余部分一直保持有效。它会一直保持最后一次迭代的值 2. 读取列表中的复杂值🌰:for test in I don&#39;t know if this&#39;ll work #会出错for test in I don\&#39;t know if &quot;this&#39;ll&quot; work #正确 * 使用转义字符(反斜线)来将单引号转义; * 使用双引号来定义用到单引号的值。for循环假定每个值都是用空格分割的，如果在单独的数据值中有空格，就必须用双引号将这些值圈起来 3. 从变量读取列表🌰:for state in $list 4. 从命令读取值生成列表中所需值的另外一个途径就是使用命令的输出。可以用命令替换来执行任何能产生输出的命令，然后在for命令中使用该命令的输出🌰:for var in $(order) 5. 字段分隔符IFS环境变量IFS，叫作内部字段分隔符(internal field separator)。IFS环境变量定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将下列字符当作字段分隔符: * 空格 * 制表符 * 换行符 1234IFS.OLD=$IFSIFS=$&apos;\n&apos;&lt;在代码中使用新的IFS值&gt; IFS=$IFS.OLD 如果要指定多个IFS字符，只要将它们在赋值行串起来就行。🌰:IFS=$’\n’:;”这个赋值会将换行符、冒号、分号和双引号作为字段分隔符。 6. 用通配符读取目录for file in /home/rich/test/*for命令的c语言格式 1234for (( variable assignment ; condition ; iteration process ))do ···done 变量可以定义多个，条件只能有一个 四、WHILE命令只要测试条件成立，while命令就会不停地循环执行定义好的命令while命令的格式是: 1234while test command do other commandsdone test command:任何普通的bash shell命令，或者用test命令进行条件测试,但退出状态码必须随着循环中运行的命令而改变。如果退出状态码不发生变化， while循环就将一直不停地进行下去 1. 使用多个测试命令while命令允许你在while语句行定义多个测试命令。只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环需要⚠️的是在每次迭代中所有的测试命令都会被执行,包括测试命令失败的最后一次迭代。另一处要留意的是该如何指定多个测试命令。注意,每个测试命令都出现在单独的一行上 123456while echo $var1 [ $var1 -ge 0 ]do echo &quot;This is inside the loop&quot; var1=$[ $var1 - 1 ]done 五、UNTIL命令until命令和while命令工作的方式完全相反。until命令要求你指定一个通常返回非零退出状态码的测试命令。只有测试命令的退出状态码不为0，bash shell才会执行循环中列出的命令 1234until test commanddo other commands done 六、控制循环 break命令 跳出单个循环:在shell执行break命令时，它会尝试跳出当前正在执行的循环 跳出内部循环:在处理多个循环时，break命令会自动终止你所在的最内层的循环 跳出外部循环:有时你在内部循环，但需要停止外部循环。break命令接受单个命令行参数值:break n 其中n指定了要跳出的循环层级。默认情况下，n为1，表明跳出的是当前的循环。如果你将n设为2，break命令就会停止下一级的外部循环 continue命令 continue命令可以提前中止某次循环中的命令，但并不会完全终止整个循环。可以在循环 内部设置shell不执行命令的条件 和break命令一样，continue命令也允许通过命令行参数指定要继续执行哪一级循环: continue n其中n定义了要继续的循环层级。 处理循环输出对循环的输出使用管道或进行重定向可以通过在done命令之后添加一个处理命令来实现(将循环内的标准输出重定向到指定文件；或通过管道将输出进行处理）要想把数据从文件中送入while命令，只需在while命令尾部使用一个重定向符123456input=&quot;users.csv&quot;while IFS=&apos;,&apos; read -r userid namedo echo &quot;adding $userid&quot; useradd -c &quot;$name&quot; -m $useriddone &lt; &quot;$input&quot; $input变量指向数据文件，并且该变量被作为while命令的重定向数据,作为输入]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux命令]]></title>
    <url>%2F2019%2F07%2F29%2FLinux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.touch:创建空文件2.cp:命令将源文件复制成一个新文件3.ln:创建硬链接4.mv:将文件和目录移动到另一个位置或重新命名5.mkdir:创建目录6.rmdir:删除目录7.file:探测文件的内部，并决定文件是什么类型的8.cat、more和less:查看文件全部内容，而tail和head命令查看文件中的一小部分内容9.ps:输出运行在系统上的所有程序的许多信息,只能显示某个特定时间点的信息10.top:显示进程信息，但它是实时显示的11.kill:PID结束进程12.killall:通过进程名而不是PID来结束进程13.mount:输出当前系统上挂载的设备列表,在虚拟目录中挂载设备14.umount:卸载设备15.du:显示某个特定目录(默认情况下是当前目录)的磁盘使用情况16.jobs:显示出当前运行 在后台模式中的所有用户的进程(作业)17.coproc:进行协程处理🌰 coproc My_Job { sleep 10; }，必须确保在第一个花括号({)和命令名之间有一个空格。还必须保证命令以分号(;)结尾。另外，分号和闭花括号(})之间也得有一个空格。18.which和type命令找到外部命令 命令type -a显示出了每个命令的两种实现。注意，which命令只显示出了外部命令文件19.history:查看最近用过的命令列表 !!唤出刚刚用过的那条命令来使用20.alias:shell的内建命令,创建别名21.env或printen:查看全局变量,显示个别环境变量的值，可以使用printenv命令22.set:显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量23.unset:删除变量，⚠️ 不要使用$24.useradd:添加新用户25.userdel:删除用户 默认情况下，userdel命令会只 删除/etc/passwd文件中的用户信息，而不会删除系统中属于该账户的任何文件。如果加上-r参数，userdel会删除用户的HOME目录以及邮件目录。然而，系统上仍可能存有已删除用户的其他文件26.usermod passwd chpasswd chage chfn chsh修改用户账户的字段，还可以指定主要组以及附加组的所属关系修改已有用户的密码从文件中读取登录名密码对，并更新密码修改密码的过期日期修改用户账户的备注信息 修改用户账户的默认登录shell 27.chpasswd:从标准输入自动读取登录名和密码对(由冒号分割)列表，给密码加密，然后为用户账户设置。可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。28.groupadd:创建新组==&gt;usermod将用户加入组中29.groupmod:修改组30.umask:设置所创建文件和目录的默认权限31.chmod:改变文件权限32.chown:改变文件的属主,也支持同时改变文件的属主和属组33.chgrp:改变文件的默认属组都属于该目录的属组，这个组也就成为了每个用户的属组34.fdisk:分区35.partprob或hdparm:让系统 读取更新过的分区表36.jobs:允许查看shell当前正在处理的作业]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux知识点]]></title>
    <url>%2F2019%2F07%2F29%2FLinux%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.Linux经常采用隐藏文件来保存配置信息,在Linux上,隐藏文件通常是文件名以点号开始的文件。2.标准通配符:问号(?)代表一个字符,星号(*)代表零个或多个字符,[]中括号表示一个字符位置并给出多个可能的选择,感叹号(!)将不需要的内容排除在外3.符号链接&amp;&amp;硬链接:符号链接就是一个实实在在的文件,与所指向的文件是两个完全不同的文件；硬链接会创建独立的虚拟文件，其中包含了原始文件的信息及位置。但是它们从根本上而言不是同一个文件。引用硬链接文件等同于引用了源文件。4.将进程列表置入后台模式:在后台模式中运行命令可以在处理命令的同时让出CLI，以供他用,要想将命令置入后台模式，可以在命令末尾加上字符&amp;。在CLI中运用子shell的创造性方法之一就是将进程列表置入后台模式。你既可以在子shell中 进行繁重的处理工作，同时也不会让子shell的I/O受制于终端。5.协程可以同时做两件事。它在后台生成一个子shell，并在这个子shell中执行命令。6.外部命令，有时候也被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell 程序的一部分。外部命令程序通常位于/bin、/usr/bin、/sbin或/usr/sbin中.当外部命令执行时,会创建出一个子进程。这种操作被称为衍生(forking),发送信号(signaling)使得进程间可以通过信号进行通信7.内建命令和外部命令的区别在于前者不需要使用子进程来执行。它们已经和shell编译成了一 体，作为shell工具的组成部分存在。不需要借助外部程序文件来运行。8.命令历史记录被保存在隐藏文件.bash_history中，它位于用户的主目录中。这里要注意的是， bash命令的历史记录是先存放在内存中，当shell退出时才被写入到历史文件中。可以在退出shell会话之前强制将命令历史记录写入.bash_history文件。要实现强制写入，需 要使用history命令的-a选项9.子shell无法使用export命令改变父shell中全局环境变量的值10.环境变量持久化:对全局环境变量来说(Linux系统中所有用户都需要使用的变量),可能更倾向于将新的或修改过的变量设置放在/etc/profile文件中，但这不是什么好主意。如果你升级了所用的发行版,这个文件也会跟着更新，那你所有定制过的变量设置可就都没有了。最好是在/etc/profile.d目录中创建一个以.sh结尾的文件。把所有新的或修改过的全局环境变 量设置放在这个文件中。11.BASH_ENV环境变量:当shell启动一个非交互式shell进程时,它会检查这个环境变量来查看要执行的启动文件,如果有指定的文件，shell会执行该文件里的命令，这通常包括shell脚本变量设置。12.用户权限是通过创建用户时分配的用户ID(User ID，通常缩写为UID)来跟踪的。UID是数值，每个用户都有唯一的UID，但在登录系统时用的不是UID，而是登录名。登录名是用户用来登录系统的最长八字符的字符串(字符可以是数字或字母)，同时会关联一个对应的密码。13.Linux系统会为各种各样的功能创建不同的用户账户，而这些账户并不是真的用户。这些账户叫作系统账户，是系统上运行的各种服务进程访问资源用的特殊账户。所有运行在后台的服务都需要用一个系统用户账户登录到Linux系统上。14.当一个用户在/etc/passwd文件中指定某个组作为默认组时,用户账户不会作为该组成员再出现在/etc/group文件中。15.umask值只是个掩码,它会屏蔽掉不想授予该安全级别的权限要把umask值从对象的全权限值中减掉。对文件来说，全权限的值是666(所有用户都有读和写的权限);而对目录来说，则是777(所有用户都有读、写、执行权限)。所以文件一开始的权限是666，减去umask值022之后，剩下的文件权限就成了644。16.只有root用户能够改变文件的属主。任何属主都可以改变文件的属组，但前提是属主必须是原属组和目标属组的成员17.共享文件:SGID位对文件共享非常重要,启用SGID位后,你可以强制在一个共享目录下创建的新文件chomd suid:4 + sgid:2 +粘着位:1 =7记得要umask 002，默认022组成员没有w权限18.日志文件系统不再使用之前先将数据直接写入存储设备再更新索引节点表的做法，而是先将文件的更改写入到临时文件(称作日志，journal)中。在数据成功写到存储设备和索引节点表之后，再删除对应的日志条目]]></content>
      <categories>
        <category>categories</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-目录(积累)]]></title>
    <url>%2F2019%2F07%2F16%2FLinux%E2%80%94%E7%9B%AE%E5%BD%95%EF%BC%88%E7%A7%AF%E7%B4%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Linux—目录（积累）文件系统层级标准FHS /etc/locale.conf:记录了系统语言变量配置尤其注意LANG &amp;&amp; LC_ALL这两个变量History指令配合”!数字”一起使用可下达曾经使用的指令 ~/.bash_history:注销账户后自动将历史记录存在这里 /etc/issue:终端机进站画面配置/etc/issue.net:远程登录时的终端进入画面配置 /etc/motd:终端登录后显示给使用者的讯息 /etc/profile &amp;&amp; (/.bash_profile ||/.bash_login|| ~/.profile):login shell 的配置文件/etc/profile.d/*.sh:使用者具有r权限就会被/etc/profile呼叫进来 ～/.bashrc:会被~/.bash_profile呼叫，同时也是non-login shell 的配置文件，会呼叫/etc/profile.d/*.sh &amp;&amp; /etc/bashrc(Centos特有),如果bash是作为交互式shell启动的,它就不会访问/etc/profile文件,只会检查用户HOME目录中的.bashrc文件 .bashrc文件有两个作用:一是查看/etc目录下通用的bashrc文件，二是为用户提供一个定制自己的命令别名和私有脚本函数的地方 /etc/man_db.conf:将/usr/local/softpackage/man放入其中，以供使用man来查询软件的说明 /etc/inittab:内含管理开机自动启动进程的表 /etc/init.d:将开机时启动 或停止某个应用的脚本放在这个目录下，这些脚本通过/etc/rcX.d目录下的入口(entry)1启动， 这里的X代表运行级(run level) /mnt和/media:挂载目录，可移动媒体设备的常用挂载点 /proc:进程目录，存放现有硬件及当前进程的相关信息 /bin:二进制目录，存放许多用户级的GNU工具 /sbin:系统二进制目录，存放许多GNU管理员级工具 /tmp:临时目录，可以在该目录中创建和删除临时工作文件 “.”,”..”:当前目录,当前目录的父目录 /bin/sh:默认的系统,用于系统shell脚本 /etc/passwd:将用户的登录名匹配到对应的UID值登录用户名 用户密码、用户账户的UID(数字形式)、用户账户的组ID(GID)(数字形式) 、用户账户的文本描述(称为备注字段) 、用户HOME目录的位置、用户的默认shell /etc/shadow:保存用户密码，只有root用户才能访问 /etc/default/useradd:usradd命令默认值储存 /etc/skel:创建新用户HOME目录时的模板,默认的HOME目录配置 /etc/group:包含系统上用到的每个组的信息 组名、组密码、GID、属于该组的用户列表/etc/login.defs:ubuntu中储存umask值 /etc/cron.*ly:定时处理目录内的内容脚本]]></content>
      <categories>
        <category>categories</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-堆]]></title>
    <url>%2F2019%2F07%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86%2F</url>
    <content type="text"><![CDATA[堆1. 定义优先队列(Priority Queue):特殊的“队列”，取出元素的顺序是 依照元素的优先权(关键字)大小，而不是元素进入队列的先后顺序2.堆的两个特性结构性:用数组表示的完全二叉树; 有序性:任一结点的关键字是其子树所有结点的最大值(或最小值) 最大堆(MaxHeap)”,也称“大顶堆”:最大值 最小堆(MinHeap)”,也称“小顶堆” :最小值 3.数据结构 : (完全二叉树)因为是完全二叉树，所以可以使用数组来储存123456typedef struct HeapStruct *MaxHeap;struct HeapStruct &#123; ElementType *Elements; /* 存储堆元素的数组 */ int Size; /* 堆的当前元素个数 */ int Capacity; /* 堆的最大容量 &#125;; ⚠️数组中的第一个元素不使用⚠️数组中的第一个元素设为哨兵 H-&gt;Element[ 0 ] 是哨兵元素，最大(小)堆中它不小于堆 中的最大(小)元素，控制顺环结束。 4 .堆的一些基本操作集 MaxHeap Create( int MaxSize ):创建一个空的最大堆。 Boolean IsFull( MaxHeap H ):判断最大堆H是否已满。 Insert( MaxHeap H, ElementType item ):将元素item插入最大堆H。 Boolean IsEmpty( MaxHeap H ):判断最大堆H是否为空。 ElementType DeleteMax( MaxHeap H ):返回H中最大元素(高优先级)。 堆的创建初始化12345678910MaxHeap Create( int MaxSize )&#123; /* 创建容量为MaxSize的空的最大堆 */ MaxHeap H = malloc( sizeof( struct HeapStruct ) ); H-&gt;Elements = malloc( (MaxSize+1)*sizeof(ElementType)); H-&gt;Size = 0; H-&gt;Capacity = MaxSize; H-&gt;Elements[0] = MaxData; /* 定义“哨兵”为大于堆中所有可能元素的值，便于以后更快操作 */ return H; &#125; 堆的插入操作* 代码123456789101112void Insert( MaxHeap H, ElementType item )&#123; /* 将元素item 插入最大堆H，其中H-&gt;Elements[0]已经定义为哨兵*/ int I; if ( IsFull(H) ) &#123; printf(“最大堆已满”); return; &#125; i = ++H-&gt;Size; /*指向插入后堆中的~最后一个元素的位置*/ for ( ; H-&gt;Elements[i/2] &lt; item; i/=2 ) /*哨兵元素在这里起作用了哦，因为堆中所有元素都小于哨兵元素，所以限制了最大元素继续上移*/ H-&gt;Elements[I] = H-&gt;Elements[I/2]; /* 向下过滤结点 */ H-&gt;Elements[I] = item; /* 将item 插入 */ &#125; * 图解 堆的删除操作1234567891011121314151617181920212223ElementType DeleteMax( MaxHeap H ) &#123; /* 从最大堆H中取出键值为最大的元素，并删除一个结点 */ int Parent, Child; ElementType MaxItem, temp; if ( IsEmpty(H) ) &#123; printf(“最大堆已为空”); return; &#125; MaxItem = H-&gt;Elements[1]; /* 取出根结点最大值 */ /* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */ temp = H-&gt;Elements[H-&gt;Size—]; for( Parent=1; Parent*2&lt;=H-&gt;Size; Parent=Child ) &#123; Child = Parent * 2; //此时chlid指向右节点 if( (Child!= H-&gt;Size) &amp;&amp;(H-&gt;Elements[Child] &lt; H-&gt;Elements[Child+1]) ) /* Child指向左右子结点的较大者 */ Child++; if( temp &gt;= H-&gt;Elements[Child] ) /*temp大于Child指向左右子结点的较大者*/ break; /*此时break出来表示此时的parent就是temp元素要放置的位置*/ else /* 移动temp元素到下一层 */ H-&gt;Elements[Parent] = H-&gt;Elements[Child]; &#125; H-&gt;Elements[Parent] = temp; return MaxItem; &#125; ⚠️理解:first弹出根结点元素，second将二叉树叶子结点的最右边的节点(即)放置到根结点的位置（不是真放），third将根结点与左右子节点中的最大节点比较，小于则将子节点上移。 最大堆的建立123456 void create(MaxHeap H,int N)&#123; ElementType a; for(int I=0;i&lt;N;i++)&#123; scanf(“%d”,&amp;a); insert( H,a );&#125;]]></content>
  </entry>
</search>
